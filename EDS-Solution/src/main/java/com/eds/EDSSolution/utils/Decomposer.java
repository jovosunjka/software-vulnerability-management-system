package com.eds.EDSSolution.utils;

import com.eds.EDSSolution.EDS_Library.diagram.*;
import com.eds.EDSSolution.model.risk_pattern.DiagramPattern;

import javax.xml.bind.JAXBElement;
import java.util.*;
import java.util.stream.Collectors;

public class Decomposer {
    private String diagramName; // diagram name or complex process name
    private List<JAXBElement<? extends BlockElement>> diagramElements;
    private List<JAXBElement<? extends Flow>> diagramFlows;
    private List<Diagram.Elements.ComplexProcess> complexProcesses;

    public List<Diagram.Elements.ComplexProcess> getComplexProcesses() {
        return this.complexProcesses;
    }

    public Decomposer(Diagram.Elements.ComplexProcess cp) {
        this.diagramName = cp.getName();
        this.diagramElements = cp.getComplexElements().getOrWebApplicationOrWebServiceOrWebServer();
        this.diagramFlows = cp.getFlows().getOrBinaryOrHttpOrHttps();
        this.complexProcesses = new ArrayList<>();
    }

    public List<JAXBElement<? extends BlockElement>> getDiagramElements() {
        return diagramElements;
    }

    public void setDiagramElements(List<JAXBElement<? extends BlockElement>> diagramElements) {
        this.diagramElements = diagramElements;
    }

    public List<JAXBElement<? extends Flow>> getDiagramFlows() {
        return diagramFlows;
    }

    public void setDiagramFlows(List<JAXBElement<? extends Flow>> diagramFlows) {
        this.diagramFlows = diagramFlows;
    }

    public Decomposer(Diagram diagram) {
        this.diagramName = diagram.getName();
        this.diagramElements = diagram.getElements().getOrWebApplicationOrWebServiceOrWebServer();
        this.diagramFlows = diagram.getFlows().getOrBinaryOrHttpOrHttps();
        this.complexProcesses = new ArrayList<>();
    }

    public Decomposer() {
    }

    public String getDiagramName() {
        return diagramName;
    }

    public List<DiagramPattern> decomposeAllPatterns() {
        ArrayList<DiagramPattern> patterns = new ArrayList<DiagramPattern>();
        for (Object blockElement : diagramElements) {
            // skip complex process
            /*if (!(((JAXBElement) blockElement).getDeclaredType() == Diagram.Elements.ComplexProcess.class)) {
                JAXBElement<? extends BlockElement> el = (JAXBElement<? extends BlockElement>) blockElement;
                patterns.addAll(getPatternsForElement(el.getValue()));
            }*/

            // don't skip complex process
            JAXBElement<? extends BlockElement> el = (JAXBElement<? extends BlockElement>) blockElement;
            patterns.addAll(getPatternsForElement(el.getValue()));
        }
        return patterns;
    }

    public void setComplexProcess() {
        for (Object blockElement : diagramElements) {
            if (((JAXBElement) blockElement).getDeclaredType() == Diagram.Elements.ComplexProcess.class) {
                JAXBElement<Diagram.Elements.ComplexProcess> c = (JAXBElement<Diagram.Elements.ComplexProcess>) blockElement;
                this.complexProcesses.add(c.getValue());
            }
        }
    }

    public List<DiagramPattern> decomposeSinglePatterns(BlockElement blockElement) {
        return getPatternsForElement(blockElement);
    }

    private List<DiagramPattern> getPatternsForElement(BlockElement baseAnalyzeElement) {
        List<DiagramPattern> patterns = new ArrayList<DiagramPattern>();

        HashSet<String> analyzedElements = new HashSet<>();
        HashSet<String> addedElements = new HashSet<>();
        Stack<BlockElement> toAnalyzeElements = new Stack<BlockElement>();
        Stack<Element> analyzingSequence = new Stack<Element>();

        toAnalyzeElements.push(baseAnalyzeElement);
        analyzedElements.add(baseAnalyzeElement.getId());

        DiagramPattern basePattern = new DiagramPattern(baseAnalyzeElement, null, null);
        patterns.add(basePattern);

        while (!toAnalyzeElements.isEmpty()) {

            boolean discoveredNew = false;
            BlockElement analyzeElement = toAnalyzeElements.peek();

            // uzmi sve flows 훾iji je destination trenutni element koji se analizira
            List<JAXBElement<? extends Flow>> flows = diagramFlows.stream().filter(
                    f -> ((BlockElement) f.getValue().getDestination()).getId().equals(analyzeElement.getId()))
                    .collect(Collectors.toList());
            Flow linkingFlow = null;

            for (JAXBElement<? extends Flow> flow : flows) {
                // ako lista analiziranih 훾vorova ne sadr탑i Source trenutnog flow-a, dodaj ga
                if (!analyzedElements.contains(((BlockElement) flow.getValue().getSource()).getId())) {
                    discoveredNew = true;
                    linkingFlow = flow.getValue();
                    toAnalyzeElements.push((BlockElement) flow.getValue().getSource());
                    analyzedElements.add(((BlockElement) flow.getValue().getSource()).getId());
                    break;
                }
            }

            // dodaj u sekvencu Element koji se analizira
            analyzingSequence.push(analyzeElement);
            // ako postoji flow koji vodi do elementa dodaj ga
            if (linkingFlow != null) {
                analyzingSequence.push(linkingFlow);
            }

            // ako se element od kog se krenulo razlikuje od elementa koji se trenutno analizira
            // i trenutni, koji se analizira, ne postoji u listi 훾vorova koji su obradjeni
            if (baseAnalyzeElement.getId() != analyzeElement.getId() && !
                    addedElements.contains(analyzeElement.getId())) {
                @SuppressWarnings({"unchecked", "rawtypes"})
                List<Element> traceList = new ArrayList(analyzingSequence); // traceList - putanja koja vodi do elementa koji se analizira
                traceList.remove(0);    //	uklanja se element do kog vodi trace (onaj koji se analizira)
                Collections.reverse(traceList);
                if (traceList.get(0) instanceof Flow) {
                    traceList.remove(0);
                }

                DiagramPattern pattern = new DiagramPattern(baseAnalyzeElement, analyzeElement, traceList);
                patterns.add(pattern);
                addedElements.add(((BlockElement) traceList.get(0)).getId());
            }

            if (!discoveredNew && !analyzingSequence.isEmpty()) {
                toAnalyzeElements.pop();
                analyzingSequence.pop();
                if (!analyzingSequence.isEmpty()) {
                    analyzingSequence.pop();
                    if (!analyzingSequence.isEmpty()) {
                        analyzingSequence.pop();
                    }
                }
            }

        }

        return patterns;
    }

}
