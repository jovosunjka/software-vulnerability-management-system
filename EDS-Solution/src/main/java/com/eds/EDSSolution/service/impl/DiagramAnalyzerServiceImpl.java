package com.eds.EDSSolution.service.impl;

import com.eds.EDSSolution.EDS_Library.diagram.*;
import com.eds.EDSSolution.exceptions.*;
import com.eds.EDSSolution.model.dto.*;
import com.eds.EDSSolution.model.report.*;
import com.eds.EDSSolution.model.risk_pattern.CVEitem;
import com.eds.EDSSolution.model.risk_pattern.CweItem;
import com.eds.EDSSolution.model.risk_pattern.DiagramPattern;
import com.eds.EDSSolution.service.CweService;
import com.eds.EDSSolution.service.DiagramAnalyzerService;
import com.eds.EDSSolution.service.NVDvulnerabilitiesService;
import com.eds.EDSSolution.service.ReportService;
import com.eds.EDSSolution.utils.*;
import org.apache.fop.apps.FOPException;
import org.json.simple.parser.ParseException;
import org.kie.api.runtime.StatelessKieSession;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.InputStreamResource;
import org.springframework.stereotype.Service;
import org.xml.sax.SAXException;

import javax.xml.bind.JAXBElement;
import javax.xml.bind.JAXBException;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.TransformerException;
import java.io.*;
import java.util.*;
import java.util.stream.Collectors;

@Service
public class DiagramAnalyzerServiceImpl implements DiagramAnalyzerService {

    @Autowired
    private NVDvulnerabilitiesService nvdVulnerabilitiesService;

    @Autowired
    private CweService cweService;

    @Autowired
    private ReportService reportService;

    private ResourcesLocation resourcesLocation = new ResourcesLocation();

    private ExploitDefinitions exploitDefinitions;
    private Object exploitDefinitionsLock = new Object();

    @Override
    public ThreatsAndVulnerabilitiesAndWeaknessesDTO/*ThreatsAndVulnerabilitiesDTO*/ analyze(String diagramXml) throws IOException, ParseException {

        String schemaPath = resourcesLocation.getSchemaLocation();

        /* ********	        VALIDATING XML DIAGRAM			**********/
        if (!validateDiagram(diagramXml, schemaPath)) {
            return null;
        }

        Decomposer decomposer = decomposeDiagram(diagramXml);
        // decomposer.setComplexProcess();   // if there are any complex processes on the diagram set them

        // ThreatsAndVulnerabilitiesDTO threatsAndVulnerabilitiesDTO = analyzeAllLevels(decomposer);
        // return threatsAndVulnerabilitiesDTO;

        ThreatsAndVulnerabilitiesAndWeaknessesDTO threatsAndVulnerabilitiesAndWeaknessesDTO = analyzeAllLevels(decomposer);
        return  threatsAndVulnerabilitiesAndWeaknessesDTO;
    }

    private ThreatsAndVulnerabilitiesAndWeaknessesDTO/*ThreatsAndVulnerabilitiesDTO*/ analyzeAllLevels(Decomposer decomposer) throws IOException, ParseException {
        Objects.requireNonNull(decomposer, "Argument 'decomposer' must not be null");

        decomposer.setComplexProcess(); // if there are any complex processes on the diagram set them

        // ThreatsAndVulnerabilitiesDTO threatsAndVulnerabilitiesDTO = new ThreatsAndVulnerabilitiesDTO();
        ThreatsAndVulnerabilitiesAndWeaknessesDTO threatsAndVulnerabilitiesAndWeaknessesDTO = new ThreatsAndVulnerabilitiesAndWeaknessesDTO();
        if (decomposer.getComplexProcesses().size() != 0) {
            Decomposer cpDecomposer;
            // ThreatsAndVulnerabilitiesDTO cpThreatsAndVulnerabilities;
            ThreatsAndVulnerabilitiesAndWeaknessesDTO cpThreatsAndVulnerabilitiesAndWeaknesses;
            for (Diagram.Elements.ComplexProcess complexProcess : decomposer.getComplexProcesses()) {
                cpDecomposer = new Decomposer(complexProcess);
                // cpThreatsAndVulnerabilities = analyzeAllLevels(cpDecomposer);
                // threatsAndVulnerabilitiesDTO.add(cpThreatsAndVulnerabilities);
                cpThreatsAndVulnerabilitiesAndWeaknesses = analyzeAllLevels(cpDecomposer);
                threatsAndVulnerabilitiesAndWeaknessesDTO.add(cpThreatsAndVulnerabilitiesAndWeaknesses);
            }
        }

        List<DiagramPattern> patterns = decomposer.decomposeAllPatterns();

        if (patterns.isEmpty()) {
            return threatsAndVulnerabilitiesAndWeaknessesDTO;
        }

        /* ********	        FIRE RULES      		 		***********/
        if (createAndFireRules(patterns)) {
            return null;
        }

        /* ********	        REQUEST TO NVD FOR VULNERABILITIES  **********/
        ReportVulnerabilities reportVulnerabilities = analyzeVulnerabilitiesForComponentTechnologies(decomposer);
        List<VulnerabilityDTO> vulnerabilities = DtoMapper.prepareVulnerabilityDTOs(reportVulnerabilities,
                decomposer.getDiagramName());

        threatsAndVulnerabilitiesAndWeaknessesDTO.addVulnerabilities(vulnerabilities);

        /* ********	        MERGE EXPLOITS AND DIAGRAMS	  ***********/
        DiagramMerge mergeExploits = new DiagramMerge(patterns, getExploitDefinitions());
        patterns = mergeExploits.mergeExploitsToDiagramPieces();

        threatsAndVulnerabilitiesAndWeaknessesDTO.addThreats(getThreatsList(patterns, decomposer.getDiagramName()));

        /* ********	        MERGE CWES AND DIAGRAMS	  ***********/
        cweService.mergeCwesToDiagramPieces(patterns);

        threatsAndVulnerabilitiesAndWeaknessesDTO.addWeaknesses(getWeaknessList(patterns, decomposer.getDiagramName()));

        return threatsAndVulnerabilitiesAndWeaknessesDTO;
    }

    @Override
    public InputStreamResource createReport(String diagramXml) throws TransformerException,
            IOException, FOPException, ParseException {

        String schemaPath = resourcesLocation.getSchemaLocation();

        /* ********	        VALIDATING XML DIAGRAM			**********/
        if (!validateDiagram(diagramXml, schemaPath)) {
            return null;
        }

        Decomposer decomposer = decomposeDiagram(diagramXml);
        // decomposer.setComplexProcess();   // if there are any complex processes on the diagram set them

        // ThreatsAndVulnerabilitiesDTO threatsAndVulnerabilitiesDTO = analyzeAllLevels(decomposer);
        // return threatsAndVulnerabilitiesDTO;

        ReportClass report = createReportForAllLevels(decomposer);

        /* ********	        CREATING XML REPORT				***********/
        String reportXml = createXMLReport(report);

        return reportService.generatePDF(reportXml);
    }

    private ReportClass createReportForAllLevels(Decomposer decomposer) throws IOException, ParseException {
        Objects.requireNonNull(decomposer, "Argument 'decomposer' must not be null");

        decomposer.setComplexProcess(); // if there are any complex processes on the diagram set them

        ReportClass reportClass = new ReportClass(decomposer.getDiagramName(), getExploitDefinitions());
        if (decomposer.getComplexProcesses().size() != 0) {
            Decomposer cpDecomposer;
            ReportClass cpReportClass;
            for (Diagram.Elements.ComplexProcess complexProcess : decomposer.getComplexProcesses()) {
                cpDecomposer = new Decomposer(complexProcess);

                cpReportClass = createReportForAllLevels(cpDecomposer);
                reportClass.addReportPatterns(cpReportClass.getPatterns());
                reportClass.addReportVulnerabilities(cpReportClass.getVulnerabilities());
            }
        }

        List<DiagramPattern> patterns = decomposer.decomposeAllPatterns();

        if (patterns.isEmpty()) {
            return reportClass;
        }

        /* ********	        FIRE RULES      		 		***********/
        if (createAndFireRules(patterns)) {
            return null;
        }

        /* ********	        REQUEST TO NVD FOR VULNERABILITIES  **********/
        ReportVulnerabilities reportVulnerabilities = analyzeVulnerabilitiesForComponentTechnologies(decomposer);
        reportClass.addReportVulnerabilities(reportVulnerabilities);

        /* ********	        MERGE EXPLOITS AND DIAGRAMS	  ***********/
        DiagramMerge mergeExploits = new DiagramMerge(patterns, getExploitDefinitions());
        patterns = mergeExploits.mergeExploitsToDiagramPieces();

        /* ********	        MERGE CWES AND DIAGRAMS	  ***********/
        cweService.mergeCwesToDiagramPieces(patterns);

        List<ReportPattern> reports = new ArrayList<>();
        for (DiagramPattern diagramPattern : patterns) {
            if (diagramPattern.getExploitValues().size() > 0) {
                reports.add(new ReportPattern(diagramPattern));
            }
        }
        reportClass.addReportPatterns(new ReportPatterns(reports));

        reportClass.setupDistinctWeaknesses();

        return reportClass;
    }

    private synchronized ExploitDefinitions getExploitDefinitions() {
        synchronized (this.exploitDefinitionsLock) {
            if (this.exploitDefinitions == null) {
                /* ********	        READ EXPLOITS	   	 		   ***********/
                String exploitPath = this.resourcesLocation.getExploitLocation();
                File exploits = new File(exploitPath);
                this.exploitDefinitions = readExploitDefinitions(exploits);
            }

            return  this.exploitDefinitions;
        }
    }


    /**
     * This method starts the analyzing process. There are several steps:
     * 1. Validate diagrams
     * 2. Decompose xml diagram into elements and flows
     * 3. Search for the complex processes
     * 4. If complex process exists:
     *      a) Decompose complex process into elements and flows
     *      b) Find patterns
     *      c) Fire rules
     *      d) Read exploits found on the complex process
     *      e) Merge exploits with definitions
     *
     * Two xml files are specified by the user of the system (diagramFile and exploits)
     *
     * @param diagramFile       xml diagram that should be analyzed
     * @param exploits          exploits definitions
     * @return list of all exploits found on the complex processes
     */
    @Override
    public List<ElementExploitDTO> startAnalyzer(File diagramFile, File exploits) {

        if (!validateDiagrams(diagramFile, exploits)) {
            return null;
        }

        List<ElementExploitDTO> elementExploits = new ArrayList<>();

        Decomposer decomposer = decomposeDiagram(diagramFile);
        decomposer.setComplexProcess();   // if there are any complex processes on the diagram set them

        if (decomposer.getComplexProcesses().size() != 0) {
            for (Diagram.Elements.ComplexProcess complexProcess : decomposer.getComplexProcesses()) {
                Decomposer cpDecomposer = new Decomposer(complexProcess);

                /* ********	        DECOMPOSE COMPLEX PROCESS 		***********/
                List<DiagramPattern> complexProcessPatterns = cpDecomposer.decomposeAllPatterns();

                /* ********	        FIRE RULES      		 		***********/
                if (createAndFireRules(complexProcessPatterns)) {
                    return null;
                }
                /* ********	        READ EXPLOITS	   	 		   ***********/
                ExploitDefinitions exploitDefinitions = readExploitDefinitions(exploits);

                /* ********	        MERGE EXPLOITS AND DIAGRAMS	  ***********/
                DiagramMerge mergeExploits = new DiagramMerge(complexProcessPatterns, exploitDefinitions);
                complexProcessPatterns = mergeExploits.mergeExploitsToDiagramPieces();

                /* ********	        MERGE CWES AND DIAGRAMS	  ***********/
                cweService.mergeCwesToDiagramPieces(complexProcessPatterns);

                elementExploits.addAll(getElementExploitsList(complexProcessPatterns));
            }
        }
        return elementExploits;
    }

    /**
     * This method starts the analyzing process. There are several steps:
     * 1. Validate diagrams
     * 2. Decompose xml diagram into elements and flows
     * 3. Search for the complex processes
     * 4. If complex process exists:
     *      a) Decompose complex process into elements and flows
     *      b) Find patterns
     *      c) Fire rules
     *      d) Read exploits found on the complex process
     *      e) Merge exploits with definitions
     *
     * Two xml files are specified by the user of the system (diagramFile and exploits)
     *
     * @param diagramXml       xml diagram that should be analyzed
     * @return list of all exploits found on the complex processes
     */
    @Override
    public List<ElementExploitDTO> startAnalyzer(String diagramXml) {

        ResourcesLocation resourcesLocation = new ResourcesLocation();
        String schemaPath = resourcesLocation.getSchemaLocation();

        /* ********	        VALIDATING XML DIAGRAM			**********/
        if (!validateDiagram(diagramXml, schemaPath)) {
            return null;
        }

        List<ElementExploitDTO> elementExploits = new ArrayList<>();

        Decomposer decomposer = decomposeDiagram(diagramXml);
        decomposer.setComplexProcess();   // if there are any complex processes on the diagram set them

        if (decomposer.getComplexProcesses().size() != 0) {
            for (Diagram.Elements.ComplexProcess complexProcess : decomposer.getComplexProcesses()) {
                Decomposer cpDecomposer = new Decomposer(complexProcess);

                /* ********	        DECOMPOSE COMPLEX PROCESS 		***********/
                List<DiagramPattern> complexProcessPatterns = cpDecomposer.decomposeAllPatterns();

                /* ********	        FIRE RULES      		 		***********/
                if (createAndFireRules(complexProcessPatterns)) {
                    return null;
                }
                /* ********	        READ EXPLOITS	   	 		   ***********/
                String exploitPath = resourcesLocation.getExploitLocation();
                File exploits = new File(exploitPath);
                ExploitDefinitions exploitDefinitions = readExploitDefinitions(exploits);

                /* ********	        MERGE EXPLOITS AND DIAGRAMS	  ***********/
                DiagramMerge mergeExploits = new DiagramMerge(complexProcessPatterns, exploitDefinitions);
                complexProcessPatterns = mergeExploits.mergeExploitsToDiagramPieces();

                /* ********	        MERGE CWES AND DIAGRAMS	  ***********/
                cweService.mergeCwesToDiagramPieces(complexProcessPatterns);

                elementExploits.addAll(getElementExploitsList(complexProcessPatterns));
            }
        }
        return elementExploits;
    }

    /**
     * This method ends the analyzing process and creates final report. Steps:
     * 1. Decompose xml diagram into elements and flows
     * 2. Find patterns
     * 3. Fire rules
     * 4. Get all publicly knows vulnerabilities
     * 5. Read exploits
     * 6. Merge exploits with definitions
     * 7. Create ReportClass
     * 8. Create report - xml format
     * 9. Transform report to PDF format
     *
     * @param complexProcessElementExploits list of all exploits that should be added into final report
     * @param diagramFile                   xml diagram that is analyzed
     * @param exploits                      exploits definitions
     * @return final report
     * @throws TransformerException when transforming report into PDF
     * @throws IOException          when parsing NVD file
     * @throws FOPException         when transforming report into PDF
     * @throws ParseException       when parsing NVD file
     */
    @Override
    public InputStreamResource endAnalyzer(List<ElementExploitDTO> complexProcessElementExploits, File diagramFile,
                                           File exploits) throws TransformerException,
            IOException, FOPException, ParseException {

        Decomposer decomposer = decomposeDiagram(diagramFile);
        List<DiagramPattern> patterns = decomposer.decomposeAllPatterns();

        if (patterns.size() == 0) {
            return null;
        }

        /* ********	        ANALYZING DIAGRAM COMPONENTS	***********/
        if (createAndFireRules(patterns)) {
            return null;
        }

        /* ********	        REQUEST TO NVD FOR VULNERABILITIES  **********/
        ReportVulnerabilities vulnerabilities = analyzeVulnerabilitiesForComponentTechnologies(decomposer);

        /* ********	        READING EXPLOITS		 		***********/
        ExploitDefinitions exploitDefinitions = readExploitDefinitions(exploits);

        /* ********	        MERGING EXPLOITS AND DIAGRAMS	***********/
        DiagramMerge mergeExploits = new DiagramMerge(patterns, exploitDefinitions);
        patterns = mergeExploits.mergeExploitsToDiagramPieces();

        /* ********	        MERGE CWES AND DIAGRAMS	  ***********/
        cweService.mergeCwesToDiagramPieces(patterns);

        /* ********	        CREATING REPORT	PATTERN			**********/
        ReportClass report = createReportPatternsFromDiagramPatterns(diagramFile, patterns, complexProcessElementExploits, exploitDefinitions);

        /* ********	        CREATING XML REPORT				***********/
        // set found vulnerabilities
        report.setVulnerabilities(vulnerabilities);
        String reportXml = createXMLReport(report);

        return reportService.generatePDF(reportXml);
    }

    /**
     * Helper method that calls two other methods, that check if diagrams are valid.
     * If both diagrams, given by user, are valid method will return true.
     *
     * @param diagramFile xml diagram that should be analyzed
     * @param exploits    xml file that contains exploits definitions
     * @return true if validation was successful
     */
    private boolean validateDiagrams(File diagramFile, File exploits) {
        ResourcesLocation resourcesLocation = new ResourcesLocation();
        String schemaPath = resourcesLocation.getSchemaLocation();

        /* ********	        VALIDATING XML DIAGRAM			**********/
        if (!validateDiagram(diagramFile, schemaPath)) {
            return false;
        }

        /* ********	        VALIDATING XML EXPLOITS			***********/
        return validateExploitDefinitions(exploits, resourcesLocation.getExploitSchema());
    }


    /**
     * Method returns true if the xml diagram is valid.
     * Syntax and semantic check.
     *
     * @param diagramFile xml diagram that should be analyzed
     * @param schemaPath  path to the schema of the diagramFile
     * @return true if the diagram is valid
     */
    private boolean validateDiagram(File diagramFile, String schemaPath) {
        try {
            Validator.checkWellFormness(diagramFile);
        } catch (ParserConfigurationException e) {
            throw new ParserCouldNotBeInitializedException("Parser could not be initialized!\nPlease try again.");
        } catch (SAXException e) {
            throw new XMLFileNotWellFormedException("XML Diagram is not well formed!\nXML Diagram contains syntax errors." +
                    " Please choose another diagram or fix current.");
        } catch (IOException e) {
            throw new FileNotReadableException("File could not be read!\nPlease load file again and try again.");
        }

        try {
            Validator.checkDiagramValidity(diagramFile, schemaPath);
        } catch (SAXException e) {
            throw new XMLFileNotValidException("XML Diagram is not valid!\nXML Diagram contains semantic errors. " +
                    "Please choose another diagram or fix current.");
        } catch (IOException e) {
            throw new FileNotReadableException("File could not be read!\nPlease load file again and try again.");
        }
        return true;
    }

    /**
     * Method returns true if the xml diagram is valid.
     * Syntax and semantic check.
     *
     * @param diagramXml xml diagram that should be analyzed
     * @param schemaPath  path to the schema of the diagramFile
     * @return true if the diagram is valid
     */
    private boolean validateDiagram(String diagramXml, String schemaPath) {
        try {
            Validator.checkWellFormness(diagramXml);
        } catch (ParserConfigurationException e) {
            throw new ParserCouldNotBeInitializedException("Parser could not be initialized!\nPlease try again.");
        } catch (SAXException e) {
            throw new XMLFileNotWellFormedException("XML Diagram is not well formed!\nXML Diagram contains syntax errors." +
                    " Please choose another diagram or fix current.");
        } catch (IOException e) {
            throw new FileNotReadableException("File could not be read!\nPlease load file again and try again.");
        }

        try {
            Validator.checkDiagramValidity(diagramXml, schemaPath);
        } catch (SAXException e) {
            throw new XMLFileNotValidException("XML Diagram is not valid!\nXML Diagram contains semantic errors. " +
                    "Please choose another diagram or fix current.");
        } catch (IOException e) {
            throw new FileNotReadableException("File could not be read!\nPlease load file again and try again.");
        }
        return true;
    }


    /**
     * Method returns true if the xml with exploits is valid.
     * Syntax and semantic check.
     *
     * @param exploitsFile xml file that contains exploits definitions
     * @param schemaPath   path to the schema of the exploitsFile
     * @return true if the diagram is valid
     */
    private boolean validateExploitDefinitions(File exploitsFile, String schemaPath) {
        try {
            Validator.checkWellFormness(exploitsFile);
        } catch (ParserConfigurationException e) {
            throw new ParserCouldNotBeInitializedException("Parser could not be initialized!\nPlease try again.");
        } catch (SAXException e) {
            throw new XMLFileNotWellFormedException("Exploit Definitions XML file is not well formed!\nXML File has " +
                    "been unauthorizedly modified and contains syntax errors. Please contact the support.");
        } catch (IOException e) {
            throw new FileNotReadableException("File could not be read!\nPlease load file again and try again.");
        }

        try {
            Validator.checkExploitDefinitionsValidity(exploitsFile, schemaPath);
        } catch (SAXException e) {
            throw new XMLFileNotValidException("Exploit Definitions XML file is not valid!\nXML File has been" +
                    "unauthorizedly modified and contains semantic errors. Please contact the support.");
        } catch (IOException e) {
            throw new FileNotReadableException("File could not be read!\nPlease load file again and try again.");
        }
        return true;
    }

    /**
     * This method decomposes diagram into elements and flows.
     *
     * @param diagramFile diagram that is analyzed
     * @return Decomposer
     */
    private Decomposer decomposeDiagram(File diagramFile) {
        /* ********	        READING XML DIAGRAM TO MEMORY	***********/
        Diagram diagram = readDiagram(diagramFile);

        /* ********	        DECOMPOSING XML DIAGRAM			**********/
        return new Decomposer(diagram);
    }

    /**
     * This method decomposes diagram into elements and flows.
     *
     * @param diagramXml diagram that is analyzed
     * @return Decomposer
     */
    private Decomposer decomposeDiagram(String diagramXml) {
        /* ********	        READING XML DIAGRAM TO MEMORY	***********/
        Diagram diagram = readDiagram(diagramXml);

        /* ********	        DECOMPOSING XML DIAGRAM			**********/
        return new Decomposer(diagram);
    }

    /**
     * Method returns Diagram that is read to the memory.
     *
     * @param diagramFile xml diagram that should be analyzed
     * @return Diagram
     */
    private Diagram readDiagram(File diagramFile) {
        try {
            return XMLLinker.readXMLDiagram(diagramFile);
        } catch (JAXBException e) {
            throw new ParserCouldNotBeInitializedException("Parser could not be initialized!\nPlease try again.");
        }
    }

    /**
     * Method returns Diagram that is read to the memory.
     *
     * @param diagramXml xml diagram that should be analyzed
     * @return Diagram
     */
    private Diagram readDiagram(String diagramXml) {
        try {
            return XMLLinker.readXMLDiagram(diagramXml);
        } catch (JAXBException e) {
            throw new ParserCouldNotBeInitializedException("Parser could not be initialized!\nPlease try again.");
        }
    }

    /**
     * Method returns ExploitDefinitions that is read to the memory.
     *
     * @param exploitsFile xml file that contains exploits definitions
     * @return ExploitDefinitions
     */
    private ExploitDefinitions readExploitDefinitions(File exploitsFile) {
        try {
            return XMLLinker.readXMLExploits(exploitsFile);
        } catch (JAXBException e) {
            throw new ParserCouldNotBeInitializedException("Parser could not be initialized!\nPlease try again.");
        }
    }

    /**
     * Method creates StatelessKieSession and examines each pattern
     *
     * @param patterns list with found patterns
     * @return false if there were no Exceptions
     */
    private boolean createAndFireRules(List<DiagramPattern> patterns) {

        StatelessKieSession session;
        try {
            session = KieRulesBase.createStatelessSession();
        } catch (RuntimeException e) {
            throw new RuleFilesException("Rule base could not be built!\nThere is an error in rule definition files.");
        }
        if (session == null) {
            throw new NoRulesFilesLocationException("There are no rules files locations defined!\nPlease check the" +
                    "'resources/locations.txt' file.");
        }

        for (DiagramPattern diagramPattern : patterns) {
            session.execute(diagramPattern);
        }
        return false;
    }

    /**
     * This method analyzes all elements and checks if there are any publicly knows vulnerabilities for the
     * CPEs that are specified on the diagram elements.
     *
     * @param decomposer Decomposer with elements and flows
     * @return ReportVulnerabilities
     * @throws IOException    when parsing file
     * @throws ParseException when parsing file
     */
    private ReportVulnerabilities analyzeVulnerabilitiesForComponentTechnologies(Decomposer decomposer) throws IOException, ParseException {
        ReportVulnerabilities reportVulnerabilities = new ReportVulnerabilities();
        List<ReportElementVulnerabilities> elementVulnerabilities = new ArrayList<>();

        for (JAXBElement diagramElement : decomposer.getDiagramElements()) {
            // skip complex process for now
            if (diagramElement.getDeclaredType() == Diagram.Elements.ComplexProcess.class) {
                continue;
            }
            BlockElement blockElement = (BlockElement) diagramElement.getValue();
            CpeItems cpeItems = blockElement.getCpeItems();

            // check all CPEs that are defined for one element
            for (CpeItems.CpeItem cpItem : cpeItems.getCpeItems()) {
                List<CVEitem> cveList = nvdVulnerabilitiesService.findCVEforCPE(cpItem.getCpeUrl(), 0);

                // if there is at least one CVE add it to report
                if (cveList.size() != 0) {
                    ReportElementVulnerabilities reportVulnerability = new ReportElementVulnerabilities(blockElement, cveList);
                    elementVulnerabilities.add(reportVulnerability);
                }
            }
        }

        reportVulnerabilities.setElementVulnerabilities(elementVulnerabilities);
        return reportVulnerabilities;
    }

    /**
     * This method creates report patterns (ReportClass).
     *
     * @param diagramFile            xml diagram that should be analyzed
     * @param patterns               all found patterns
     * @param complexProcessExploits all found exploits on the complex processes
     * @param exploitDefinitions     exploit definitions
     * @return ReportClass
     */
    private ReportClass createReportPatternsFromDiagramPatterns(File diagramFile, List<DiagramPattern> patterns,
                                                                List<ElementExploitDTO> complexProcessExploits,
                                                                ExploitDefinitions exploitDefinitions) {
        List<ReportPattern> reports = new ArrayList<>();

        for (DiagramPattern diagramPattern : patterns) {
            if (diagramPattern.getExploitValues().size() > 0) {
                reports.add(new ReportPattern(diagramPattern));
            }
        }

        return new ReportClass(reports, diagramFile.getName(), complexProcessExploits, exploitDefinitions);
    }

    /**
     * This method writes the xml report file.
     *
     * @param report          ReportClass
     * @return report in xml format
     */
    private String createXMLReport(ReportClass report) {
        try {
            return XMLLinker.writeXMLReportFile(report);
        } catch (JAXBException e) {
            throw new ReportFileNotWrittenException("Report File could not be written!\nPlease try again.");
        }
    }

    /**
     * Helper method that iterates through all patterns, found on the complex process, and
     * creates list of ElementExploitDTOs that is going to be returned to the user.
     *
     * @param complexProcessPatterns all patterns found on complex process
     * @return List<ElementExploitDTO>
     */
    private List<ElementExploitDTO> getElementExploitsList(List<DiagramPattern> complexProcessPatterns) {
        List<ElementExploitDTO> elementExploits = new ArrayList<>();

        for (DiagramPattern dp : complexProcessPatterns) {
            ElementExploitDTO elementExploitDTO = new ElementExploitDTO(dp.getElement().getName(),
                    "", dp.getFoundExploits());
            elementExploits.add(elementExploitDTO);
        }
        return elementExploits;
    }

    private List<WeaknessDTO> getWeaknessList(List<DiagramPattern> patterns, String diagramName) {
        List<WeaknessDTO> weaknesses = new ArrayList<WeaknessDTO>();

        WeaknessDTO weakness;
        List<ElementOrFlowDTO> elementOrFlow;
        for (DiagramPattern dp : patterns) {
            elementOrFlow = getElementOrFlow(dp);
            for (CweItem cweItem : dp.getCweValues()) {
                weakness = new WeaknessDTO(diagramName, elementOrFlow, cweItem);
                weaknesses.add(weakness);
            }
        }
        return weaknesses;
    }

    /**
     * Helper method that iterates through all patterns, and
     * creates list of ThreatDTOs that is going to be returned to the user.
     *
     * @param patterns all patterns found on diagram
     * @return List<ThreatDTO>
     */
    private List<ThreatDTO> getThreatsList(List<DiagramPattern> patterns, String diagramName) {
        List<ThreatDTO> threats = new ArrayList<ThreatDTO>();

        ThreatDTO threat;
        List<ElementOrFlowDTO> elementOrFlow;
        for (DiagramPattern dp : patterns) {
            elementOrFlow = getElementOrFlow(dp);
            for (ExploitDefinition exploit : dp.getExploitValues()) {
                threat = new ThreatDTO(exploit.getExploitId(), diagramName,exploit.getExploitTitle(),
                        exploit.getDescription(), exploit.getCountermeasures(), elementOrFlow, dp.getAssetValues());
                threats.add(threat);
            }
        }
        return threats;
    }

    private List<ElementOrFlowDTO> getElementOrFlow(DiagramPattern dp) {
        List<ElementOrFlowDTO> elementOrFlow;
        if (dp.getTrace() != null && !dp.getTrace().isEmpty()) {
            elementOrFlow = dp.getTrace().stream()
                    .map(t -> new ElementOrFlowDTO( t.getId(), t.getName(),
                            t instanceof BlockElement ? "element" : "flow")
                    )
                    .collect(Collectors.toList());
            elementOrFlow.add(
                    new ElementOrFlowDTO(dp.getElement().getId(), dp.getElement().getName(), "element")
            );
        }
        else {
            elementOrFlow = new ArrayList<ElementOrFlowDTO>();
            if (dp.getElement() != null) {
                elementOrFlow.add(
                        new ElementOrFlowDTO(dp.getElement().getId(), dp.getElement().getName(), "element")
                );
            }
            else if (dp.getTraceStart() != null) {
                elementOrFlow.add(
                        new ElementOrFlowDTO(dp.getTraceStart().getId(), dp.getTraceStart().getName(), "element")
                );
            }
            else {
                elementOrFlow.add(
                        new ElementOrFlowDTO("None", "None", "None")
                );
            }
        }

        return elementOrFlow;
    }


    @SuppressWarnings("unused")
    private void printDiagramPatterns(List<DiagramPattern> diagramPatterns) {
        for (DiagramPattern pattern : diagramPatterns) {
            if (pattern.getTraceStart() != null) {
                System.out.println("\n********* Pattern for " + pattern.getElement().getName() + "\n- Trace for " + pattern.getTraceStart().getName() + ":");
                for (Element element : pattern.getTrace()) {
                    System.out.println("\t " + element.getName());
                }
            } else {
                System.out.println("\n********* Pattern " + pattern.getElement().getName() + " with no trace");
            }
        }
    }

    @SuppressWarnings("unused")
    private void printRawExploitsForDiagramPatterns(List<DiagramPattern> diagramPatterns) {
        for (DiagramPattern pattern : diagramPatterns) {
            if (pattern.getTraceStart() != null) {
                System.out.println("*******************\nExploits on element " + pattern.getElement().getName() + "\n- Trace for " + pattern.getTraceStart().getName() + ":");
                for (String exploit : pattern.getFoundExploits()) {
                    if (exploit != null) {
                        System.out.println("\t\t- " + exploit); //+ " \t asset: " + exploit.getAsset());
                    }
                }
            } else {
                System.out.println("*******************\nExploits on element " + pattern.getElement().getName() + " with no trace:");
                for (String exploit : pattern.getFoundExploits()) {
                    if (exploit != null) {
                        System.out.println("\t\t- " + exploit); // + " \t asset: " + exploit.getAsset());
                    }
                }
            }
        }
    }

    @SuppressWarnings("unused")
    private void printExploitsForDiagramPatterns(List<DiagramPattern> diagramPatterns) {
        System.out.println("\n*************************************************************************");
        System.out.println("*************************************************************************\n");
        for (DiagramPattern pattern : diagramPatterns) {
            if (pattern.getTraceStart() != null) {
                System.out.println("*******************\n" + pattern.getElement().getName() + " from " + pattern.getTraceStart().getName() + ":");
                for (ExploitDefinition exploit : pattern.getExploitValues()) {
                    if (exploit != null) {
                        System.out.println("\t\t- " + exploit.getExploitTitle());
                    }
                }
            } else {
                System.out.println("*******************\n" + pattern.getElement().getName() + " with no trace:");
                for (ExploitDefinition exploit : pattern.getExploitValues()) {
                    if (exploit != null) {
                        System.out.println("\t\t- " + exploit.getExploitTitle());
                    }
                }
            }
        }
    }
}
