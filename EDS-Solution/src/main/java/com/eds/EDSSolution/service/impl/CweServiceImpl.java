package com.eds.EDSSolution.service.impl;

import com.eds.EDSSolution.EDS_Library.diagram.ExploitDefinition;
import com.eds.EDSSolution.model.risk_pattern.*;
import com.eds.EDSSolution.service.CweService;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.stream.Collectors;


@Service
public class CweServiceImpl implements CweService {

    @Value("${severity.min-allowed-value}")
    private float severityMinAllowedValue;

    @Value("${severity.none-max-value}")
    private float severityNoneMaxValue;

    @Value("${severity.low-max-value}")
    private float severityLowMaxValue;

    @Value("${severity.medium-max-value}")
    private float severityMediumMaxValue;

    @Value("${severity.high-max-value}")
    private float severityHighMaxValue;

    @Value("${severity.critical-max-value}")
    private float severityCriticalMaxValue;

    // ------------------------------------------------------------

    @Value("${number-of-attempts-for-taking-cwe-item}")
    private int numberOfAttemptsForTakingCweItem;

    // ------------------------------------------------------------

    private HashMap<String, CweItem> cweItemsCache = new HashMap<String, CweItem>();

    private final String BASE_URL = "https://cwe.mitre.org";

    private final String nameCssQuery = "h2";

    private final String descriptionCssQuery = "#Description .detail .indent";

    private final String likelihoodOfExploitCssQuery = "#Likelihood_Of_Exploit .detail .indent";

    private final String detectionMethodsCssQuery = "#Detection_Methods .detail .indent table tbody tr td";

    private final String potentialMitigationsCssQuery = "#Potential_Mitigations .detail .indent table tbody tr td";

    private final String commonConsequencesCssQuery = "#Common_Consequences .tabledetail .indent table tbody tr";



   /* @EventListener(ApplicationReadyEvent.class)
    public void sdsds() {
        CweItem item = takeCweItemFromCweMitreAndSave("119");
        System.out.println(item);

    }*/

    public void mergeCwesToDiagramPieces(List<DiagramPattern> diagramPatterns) {
        CweItem cweItem;
        int maxAssetPriority;
        for (DiagramPattern pattern : diagramPatterns) {
            maxAssetPriority = pattern.getMaxAssetPriority();
            for (String cweId : pattern.getFoundCwes()) {
                cweItem = getCweItem(cweId);
                if (cweItem != null) {
                    computeAndSetSeverity(cweItem, maxAssetPriority);
                    pattern.addCweValue(cweItem);
                }
            }
        }
    }

    // https://www.atlassian.com/trust/security/security-severity-levels
    private void computeAndSetSeverity(CweItem cweItem, int maxAssetPriority) {
        float severityNumber = cweItem.getLikelihoodOfExploitNumberValue() * maxAssetPriority;
        if (severityNumber > severityCriticalMaxValue || severityNumber < severityMinAllowedValue) {
            throw new RuntimeException("severityNumber out of range [" + severityMinAllowedValue + ", " +
                    severityCriticalMaxValue + "]");
        }
        else if (severityNumber <= severityNoneMaxValue) {
            cweItem.setSeverity("None");
        }
        else if (severityNumber <= severityLowMaxValue) {
            cweItem.setSeverity("Low");
        }
        else if (severityNumber <= severityMediumMaxValue) {
            cweItem.setSeverity("Medium");
        }
        else if (severityNumber <= severityHighMaxValue) {
            cweItem.setSeverity("High");
        }
        else if (severityNumber <= severityCriticalMaxValue) {
            cweItem.setSeverity("Critical");
        }
    }

    public CweItem getCweItem(String cweId) {
        CweItem cweItem = cweItemsCache.get(cweId);

        if (cweItem == null) {
            int counter = 0;
            while (cweItem == null && counter < numberOfAttemptsForTakingCweItem) {
                cweItem = takeCweItemFromCweMitreAndSave(cweId);
                counter++;
            }
        }

        return cweItem;
    }

    private CweItem takeCweItemFromCweMitreAndSave(String cweId) {
        try
        {
            String url = BASE_URL + "/data/definitions/" + cweId + ".html";
            Document document = Jsoup.connect(url).get();

            String name = getText(document, nameCssQuery);
            String description = getText(document, descriptionCssQuery);
            String likelihoodOfExploit = getText(document, likelihoodOfExploitCssQuery);
            List<PotentialMitigation> potentialMitigations = getPotentialMitigations(document,
                                                                                potentialMitigationsCssQuery);
            List<DetectionMethod> detectionMethods = getDetectionMethods(document, detectionMethodsCssQuery);
            List<CommonConsequence> commonConsequences = getCommonConsequences(document, commonConsequencesCssQuery);
            CweItem cweItem = new CweItem(name, description, potentialMitigations, detectionMethods,
                                                                        commonConsequences, likelihoodOfExploit);
            cweItemsCache.put(cweId, cweItem);
            // return copy of cweItem
            return new CweItem(cweItem);
        }
        catch (Exception e)
        {
            // e.printStackTrace();
            System.out.println("[ERROR]  " + e.getMessage());
            return null;
        }


    }

    private List<CommonConsequence> getCommonConsequences(Document document, String commonConsequencesCssQuery) {
        Elements elements = document.select(commonConsequencesCssQuery);

        List<CommonConsequence> commonConsequences = elements.stream()
                .filter(el -> el.selectFirst("td") != null)
                .map(el -> {
                    Elements tdElements = el.select("td");

                    Element firstTdElement = tdElements.get(0);
                    Element brElement = firstTdElement.selectFirst("br");
                    String scope = "";
                    if (brElement != null) {
                        scope = firstTdElement.html();
                    }

                    Element secondTdElement = tdElements.get(1);
                    Element technicalImpactElement = secondTdElement.selectFirst("p i");
                    String technicalImpact = "";
                    if (technicalImpactElement != null) {
                        technicalImpact = technicalImpactElement.text();
                    }
                    Elements divElements = secondTdElement.select("div");
                    int divElementsSize = divElements.size();
                    String impactText = "";
                    if (divElementsSize >=2) {
                        impactText = divElements.get(1).text();
                    }

                    Element thirdTdElement = tdElements.get(2);
                    String likelihood = "";
                    if (thirdTdElement != null) {
                        likelihood = thirdTdElement.text();
                    }

                    return new CommonConsequence(scope, new Impact(technicalImpact, impactText), likelihood);
                })
                .collect(Collectors.toList());

        return commonConsequences;
    }

    private List<PotentialMitigation> getPotentialMitigations(Document document,
                                                              String potentialMitigationsCssQuery) {
        Elements elements = document.select(potentialMitigationsCssQuery);

        List<PotentialMitigation> potentialMitigations = elements.stream()
                .map(el -> {
                    String phase = el.selectFirst(".subheading").text()
                                                .split(":")[1].trim();

                    Elements pElements = el.select(".indent .suboptheading");
                    int pElementsSize = pElements.size();
                    String strategy = null;
                    String effectiveness = null;
                    if (pElementsSize == 1) {
                        String[] tokens = pElements.get(0).text().split(":");
                        tokens[0] = tokens[0].trim();
                        if (tokens[0].equals("Strategy")) {
                            strategy = tokens[1].trim();
                        }
                        else if (tokens[0].equals("Effectiveness")) {
                            effectiveness = tokens[1].trim();
                        }
                    }
                    else if (pElementsSize >= 2) {
                        strategy =  pElements.get(0).text().split(":")[1].trim();
                        effectiveness = pElements.get(1).text().split(":")[1].trim();
                    }

                    String text = getPotentialMitigationOrDetectionMethodText(el);
                    String note = getNote(el);

                    return new PotentialMitigation(phase, strategy, text, effectiveness, note);
                })
                .collect(Collectors.toList());

        return potentialMitigations;
    }

    private List<DetectionMethod> getDetectionMethods(Document document, String detectionMethodsCssQuery) {
        Elements elements = document.select(detectionMethodsCssQuery);

        List<DetectionMethod> detectionMethods = elements.stream()
            .map(el -> {
                String name = el.selectFirst(".subheading").text();
                String text = getPotentialMitigationOrDetectionMethodText(el);
                String effectiveness = getDetectionMethodEffectiveness(el);
                String note = getNote(el);

                return new DetectionMethod(name, text, effectiveness, note);
            })
            .collect(Collectors.toList());

        return detectionMethods;
    }

    private String getPotentialMitigationOrDetectionMethodText(Element element) {
        Elements divIndentElements = element.select(".indent");

        // necemo uzimati u obzir divIndent elemente koji se odnose na Effectiveness i Note
        String text = divIndentElements.stream()
                    .filter(div -> div.selectFirst(".suboptheading") == null
                                    && div.selectFirst("b span") == null)
                    .map(el -> el.text())
                    .filter(t -> !t.trim().isEmpty())
                    .collect(Collectors.joining("\n"));
        if (text != null) {
            text = text.trim();
        }
        return text;
    }

    private String getDetectionMethodEffectiveness(Element detectionMethodElement) {
        Element pElement = detectionMethodElement.selectFirst(".indent p.suboptheading");
        if (pElement == null) {
            return null;
        }

        return pElement.text().split(":")[1].trim();
    }

    private String getNote(Element detectionMethodElement) {
        Element spanElement = detectionMethodElement.selectFirst(".indent b span");
        if (spanElement == null || (spanElement != null && !spanElement.text().contains("Note:"))) {
            return null;
        }

        Element divIndentElement = spanElement.parent().parent();
        return divIndentElement.ownText();
    }

    private String getText(Document document, String cssQuery) {
        Element element = document.selectFirst(cssQuery);
        return element.text();
    }

}
