import { Flow } from '../model/flow';
import { CpeItem } from '../model/cpe-item';
import { ImportExploit } from '../model/import-exploit';
import { Process } from '../model/process';
import { ExternalEntity } from '../model/external-entity';
import { DataStore } from '../model/data-store';
import { TrustBoundary } from '../model/trust-boundary';
import { ThreatModel } from '../model/threat-model';
import { Section } from '../model/section';
import { Asset } from '../model/asset';

export class BackendDataFormatUtils {

    public static preparContextDiagramForBackendForConvertingInXml(model: ThreatModel) {
        if (model.diagrams.length === 0) {
          return null;
        }

        const contextDiagram = model.diagrams[0];

        let elementForBackend;
        const elementsObj = {};
        // elements moze biti Process | DataStore | ExternalEntity
        contextDiagram.elements.forEach((element: any) => {
            if (element.idOfDiagram) { // za complex process element.idOfDiagram !== undefined
                const diagramForComplexProcess = model.diagrams.filter(d => d.id === element.idOfDiagram)[0];
                // complexProcessElement
                elementForBackend = {
                    complexElements: BackendDataFormatUtils.getElementsFromComplexProcessForBackend(diagramForComplexProcess.elements),
                    flows: BackendDataFormatUtils.getFlowsForBackend(diagramForComplexProcess.flows),
                    boundaries: BackendDataFormatUtils.getBoundariesForBackend(diagramForComplexProcess.boundaries),
                    sections: BackendDataFormatUtils.getSectionsForBackend(diagramForComplexProcess.sections)
                };
            } else {
                elementForBackend = {
                  exploits: BackendDataFormatUtils.getExploitsForBackend(element.exploits),
                  importExploits: BackendDataFormatUtils.getImportExploitsForBackend(element.importExploits),
                  assets: BackendDataFormatUtils.getAssetsForBackend(element.assets),
                  cpeItems: BackendDataFormatUtils.getCpeItemsForBackend(element.cpeItems),
                  _attributes: {
                    id: element.id,
                    name: element.name,
                    outOfScope: element.outOfScope,
                    outOfScopeReason: element.outOfScopeReason,
                    runLevel: element.runLevel,
                  }
                };

                const section = element.section.trim();
                if (section !== '') {
                  elementForBackend._attributes.section = section;
                }

                if (element.sanitizeInput !== undefined) {
                    elementForBackend._attributes.sanitizeInput = element.sanitizeInput;
                }
                if (element.sanitizeOutput !== undefined) {
                    elementForBackend._attributes.sanitizeOutput = element.sanitizeOutput;
                }
                if (element.hasForgeryProtection !== undefined) {
                    elementForBackend._attributes.hasForgeryProtection = element.hasForgeryProtection;
                }
                if (element.sessionHasTimeouts !== undefined) {
                    elementForBackend._attributes.sessionHasTimeouts = element.sessionHasTimeouts;
                }
                if (element.requiresAuthentication !== undefined) {
                    elementForBackend._attributes.requiresAuthentication = element.requiresAuthentication;
                }
                if (element.requiresAuthorization !== undefined) {
                    elementForBackend._attributes.requiresAuthorization = element.requiresAuthorization;
                }
                if (element.isThreadSafe !== undefined) {
                  elementForBackend._attributes.isThreadSafe = element.isThreadSafe;
                }
                if (element.dataIsEncrypted !== undefined) {
                  elementForBackend._attributes.dataIsEncrypted = element.dataIsEncrypted;
                }
                if (element.dataIsSigned !== undefined) {
                    elementForBackend._attributes.dataIsSigned = element.dataIsSigned;
                }
                if (element.storeCredentials !== undefined) {
                    elementForBackend._attributes.storeCredentials = element.storeCredentials;
                }
                if (element.hasBackup !== undefined) {
                  elementForBackend._attributes.hasBackup = element.hasBackup;
                }
            }
            if (elementsObj[element.kind] === undefined) {
              elementsObj[element.kind] = [];
            }
            elementsObj[element.kind].push(elementForBackend);
        });

        const contextDiagramForBackend = {
          _attributes: {
            xmlns: 'https://www.eds.org/eds-schemas',
            'xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance',
            'xsi:schemaLocation': 'https://www.eds.org/eds-schemas'
          },
          elements: elementsObj,
          flows: BackendDataFormatUtils.getFlowsForBackend(contextDiagram.flows),
          boundaries: { boundary: contextDiagram.boundaries.map(b => {
              return {
                  _attributes: {
                    id: b.id,
                    name: b.name
                  }
              };
          })},
          sections: BackendDataFormatUtils.getSectionsForBackend(contextDiagram.sections)
        };

        return contextDiagramForBackend;
    }

    private static getFlowsForBackend(flows: Flow[]) {
        const flowsObj = {};
        let flowForBackend;
        flows.forEach(f => {
            let source;
            if (f.source) {
              source = f.source;
            } else {
              source = 'null';
            }

            let destination;
            if (f.destination) {
              destination = f.destination;
            } else {
              destination = 'null';
            }

            flowForBackend = {
                exploits: this.getExploitsForBackend(f.exploits),
                importExploits: this.getImportExploitsForBackend(f.importExploits),
                assets: BackendDataFormatUtils.getAssetsForBackend(f.assets),
                _attributes: {
                  id: f.id,
                  name: f.name,
                  outOfScope: f.outOfScope,
                  outOfScopeReason: f.outOfScopeReason,
                  source,
                  destination,
                  containsCookies: f.containsCookies,
                  containsXML: f.containsXML
                }
            };

            if (f.boundariesCrossed.length !== 0) {
              flowForBackend.boundariesCrossed = { boundaryCross: f.boundariesCrossed.map(bc => {
                  return {
                      _attributes: {
                        boundary: bc
                      }
                  };
                })
              };
            }
            if (typeof flowsObj[f.kind] === 'undefined') {
              flowsObj[f.kind] = [];
            }
            flowsObj[f.kind].push(flowForBackend);
        });
        return flowsObj;
    }

    private static getCpeItemsForBackend(cpeItems: CpeItem[]) {
        return { cpeItem: cpeItems.map(ci => {
            return {
              description: ci.description,
              title: ci.title,
              _attributes: {
                cpeUrl: ci.cpeUrl,          }
            };
          })
        };
    }

    private static getAssetsForBackend(assets: Asset[]) {
        return { asset: assets.map(a => {
            return {
              assetId: a.assetId,
              category: a.category,
              securityGoals: {
                securityGoal: a.securityGoals
              }
            };
          })
        };
    }


    private static getSectionsForBackend(sections: Section[]) {
        return { section: sections.map(s => {
            return {
              _attributes: {
                id: s.id,
                name: s.name,
                parentSection: s.parentSection
              }
            };
          })
        };
    }

    private static getImportExploitsForBackend(importExploits: ImportExploit[]) {
        return { importExploit: importExploits.map(ie => {
            return {
              description: ie.description,
              countermeasures: ie.countermeasures,
              _attributes: {
                exploitId: ie.exploitId,
                exploitTitle: ie.exploitTitle
              }
            };
          })
        };
    }

    private static getExploitsForBackend(exploits: string[]) {
        return { exploit: exploits.map(e => {
            return {_attributes: {exploitId: e}};
          })
        };
    }

    private static getElementsFromComplexProcessForBackend(elements: (Process | ExternalEntity | DataStore)[]) {
        const that = this;
        const elementsObj = {};
        // elements moze biti Process | DataStore | ExternalEntity
        elements.forEach((element: any) => {
            const attributes: any = {
              id: element.id,
              name: element.name,
              outOfScope: element.outOfScope,
              outOfScopeReason: element.outOfScopeReason,
              runLevel: element.runLevel
            };
            const section = element.section.trim();
            if (section !== '') {
              attributes.section = section;
            }

            if (element.sanitizeInput !== undefined) {
                attributes.sanitizeInput = element.sanitizeInput;
            }
            if (element.sanitizeOutput !== undefined) {
                attributes.sanitizeOutput = element.sanitizeOutput;
            }
            if (element.hasForgeryProtection !== undefined) {
                attributes.hasForgeryProtection = element.hasForgeryProtection;
            }
            if (element.sessionHasTimeouts !== undefined) {
                attributes.sessionHasTimeouts = element.sessionHasTimeouts;
            }
            if (element.requiresAuthentication !== undefined) {
                attributes.requiresAuthentication = element.requiresAuthentication;
            }
            if (element.requiresAuthorization !== undefined) {
                attributes.requiresAuthorization = element.requiresAuthorization;
            }
            if (element.isThreadSafe !== undefined) {
              attributes.isThreadSafe = element.isThreadSafe;
            }
            if (element.dataIsEncrypted !== undefined) {
              attributes.dataIsEncrypted = element.dataIsEncrypted;
            }
            if (element.dataIsSigned !== undefined) {
                attributes.dataIsSigned = element.dataIsSigned;
            }
            if (element.storeCredentials !== undefined) {
                attributes.storeCredentials = element.storeCredentials;
            }
            if (element.hasBackup !== undefined) {
              attributes.hasBackup = element.hasBackup;
            }

            const elementForBackend = {
              exploits: that.getExploitsForBackend(element.exploits),
              importExploits: that.getImportExploitsForBackend(element.importExploits),
              assets: BackendDataFormatUtils.getAssetsForBackend(element.assets),
              cpeItems: that.getCpeItemsForBackend(element.cpeItems),
              _attributes: attributes
            };

            if (elementsObj[element.kind] === undefined) {
              elementsObj[element.kind] = [];
            }
            elementsObj[element.kind].push(elementForBackend);
        });

        return elementsObj;
    }

    private static getBoundariesForBackend(boundaries: TrustBoundary[]) {
        return { boundary: boundaries.map(b => {
            return {
                _attributes: {
                  id: b.id,
                  name: b.name
                }
            };
        })};
    }

}

