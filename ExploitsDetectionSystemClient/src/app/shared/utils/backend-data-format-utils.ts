import { Flow } from '../model/flow';
import { CpeItem } from '../model/cpe-item';
import { ImportExploit } from '../model/import-exploit';
import { Process } from '../model/process';
import { ExternalEntity } from '../model/external-entity';
import { DataStore } from '../model/data-store';
import { TrustBoundary } from '../model/trust-boundary';
import { ThreatModel } from '../model/threat-model';
import { Section } from '../model/section';
import { Asset } from '../model/asset';
import { DataFlowDiagram } from '../model/data-flow-diagram';

export class BackendDataFormatUtils {

    public static preparContextDiagramForBackendForConvertingInXml(model: ThreatModel) {
        if (model.diagrams.length === 0) {
          return null;
        }

        const contextDiagram = model.diagrams[0];
        const contextDiagramForBackend = this.prepareComplexProcessesOnAllLevels(contextDiagram, false, model);
        return contextDiagramForBackend;
    }

    private static prepareComplexProcessesOnAllLevels(diagram: DataFlowDiagram, complexProcess: boolean, model: ThreatModel) {
      let elementForBackend;
      const elementsObj = {};
      // elements moze biti Process | DataStore | ExternalEntity
      diagram.elements.forEach((element: any) => {
          elementForBackend = {
            exploits : BackendDataFormatUtils.getExploitsForBackend(element.exploits),
            importExploits : BackendDataFormatUtils.getImportExploitsForBackend(element.importExploits),
            assets : BackendDataFormatUtils.getAssetsForBackend(element.assets),
            cpeItems : BackendDataFormatUtils.getCpeItemsForBackend(element.cpeItems),
            _attributes: {
              id : element.id,
              name : element.name,
              outOfScope : element.outOfScope,
              outOfScopeReason : element.outOfScopeReason,
              runLevel : element.runLevel
            }
          };

          if (element.idOfDiagram) { // za complex process element.idOfDiagram !== undefined
              const diagramForComplexProcess = model.diagrams.filter(d => d.id === element.idOfDiagram)[0];
              // complexProcessElement
              const complexElementForBackend = BackendDataFormatUtils.prepareComplexProcessesOnAllLevels(diagramForComplexProcess,
                                                                                                         true, model);
              elementForBackend.complexElements = complexElementForBackend.complexElements;
              elementForBackend.flows = complexElementForBackend.flows;
              elementForBackend.boundaries = complexElementForBackend.boundaries;
              elementForBackend.sections = complexElementForBackend.sections;
          } else {
              const section = element.section.trim();
              if (section !== '') {
                elementForBackend._attributes.section = section;
              }

              if (element.isThreadSafe !== undefined) {
                elementForBackend._attributes.isThreadSafe = element.isThreadSafe;
              }
              if (element.dataIsEncrypted !== undefined) {
                elementForBackend._attributes.dataIsEncrypted = element.dataIsEncrypted;
              }
              if (element.dataIsSigned !== undefined) {
                  elementForBackend._attributes.dataIsSigned = element.dataIsSigned;
              }
              if (element.storeCredentials !== undefined) {
                  elementForBackend._attributes.storeCredentials = element.storeCredentials;
              }
              if (element.hasBackup !== undefined) {
                elementForBackend._attributes.hasBackup = element.hasBackup;
              }
          }

          if (element.sanitizeInput !== undefined) {
            elementForBackend._attributes.sanitizeInput = element.sanitizeInput;
          }
          if (element.sanitizeOutput !== undefined) {
              elementForBackend._attributes.sanitizeOutput = element.sanitizeOutput;
          }
          if (element.hasForgeryProtection !== undefined) {
              elementForBackend._attributes.hasForgeryProtection = element.hasForgeryProtection;
          }
          if (element.sessionHasTimeouts !== undefined) {
              elementForBackend._attributes.sessionHasTimeouts = element.sessionHasTimeouts;
          }
          if (element.requiresAuthentication !== undefined) {
              elementForBackend._attributes.requiresAuthentication = element.requiresAuthentication;
          }
          if (element.requiresAuthorization !== undefined) {
              elementForBackend._attributes.requiresAuthorization = element.requiresAuthorization;
          }

          if (elementsObj[element.kind] === undefined) {
            elementsObj[element.kind] = [];
          }
          elementsObj[element.kind].push(elementForBackend);
      });

      let diagramForBackend;
      diagramForBackend = {};
      /*  diagramForBackend = {
        name: diagram.name,
      }; */
      if (complexProcess) {
        diagramForBackend.complexElements = elementsObj;
      } else {
        diagramForBackend.name = diagram.name;
        diagramForBackend._attributes = {
          xmlns: 'https://www.eds.org/eds-schemas',
          'xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance',
          'xsi:schemaLocation': 'https://www.eds.org/eds-schemas'
        };
        diagramForBackend.elements = elementsObj;
      }
      diagramForBackend.flows = BackendDataFormatUtils.getFlowsForBackend(diagram.flows);
      diagramForBackend.boundaries = BackendDataFormatUtils.getBoundariesForBackend(diagram.boundaries);
      diagramForBackend.sections = BackendDataFormatUtils.getSectionsForBackend(diagram.sections);

      return diagramForBackend;
    }

    private static getFlowsForBackend(flows: Flow[]) {
        const flowsObj = {};
        let flowForBackend;
        flows.forEach(f => {
            let source;
            if (f.source) {
              source = f.source;
            } else {
              source = 'null';
            }

            let destination;
            if (f.destination) {
              destination = f.destination;
            } else {
              destination = 'null';
            }

            flowForBackend = {
                _attributes: {
                  id: f.id,
                  name: f.name,
                  outOfScope: f.outOfScope,
                  outOfScopeReason: f.outOfScopeReason,
                  source,
                  destination,
                  containsCookies: f.containsCookies,
                  containsXML: f.containsXML
                }
            };

            flowForBackend.exploits = this.getExploitsForBackend(f.exploits);
            flowForBackend.importExploits = this.getImportExploitsForBackend(f.importExploits);
            if (f.boundariesCrossed.length !== 0) {
              flowForBackend.boundariesCrossed = { boundaryCross: f.boundariesCrossed.map(bc => {
                  return {
                      _attributes: {
                        boundary: bc
                      }
                  };
                })
              };
            }
            flowForBackend.assets = BackendDataFormatUtils.getAssetsForBackend(f.assets);


            if (typeof flowsObj[f.kind] === 'undefined') {
              flowsObj[f.kind] = [];
            }
            flowsObj[f.kind].push(flowForBackend);
        });
        return flowsObj;
    }

    private static getCpeItemsForBackend(cpeItems: CpeItem[]) {
        return { cpeItem: cpeItems.map(ci => {
            return {
              title: ci.title,
              description: ci.description,
              _attributes: {
                cpeUrl: ci.cpeUrl,          }
            };
          })
        };
    }

    private static getAssetsForBackend(assets: Asset[]) {
        return { asset: assets.map(a => {
            return {
              assetId: a.assetId,
              category: a.category,
              securityGoals: {
                securityGoal: a.securityGoals
              }
            };
          })
        };
    }


    private static getSectionsForBackend(sections: Section[]) {
        return { section: sections.map(s => {
            return {
              _attributes: {
                id: s.id,
                name: s.name,
                parentSection: s.parentSection
              }
            };
          })
        };
    }

    private static getImportExploitsForBackend(importExploits: ImportExploit[]) {
        return { importExploit: importExploits.map(ie => {
            return {
              description: ie.description,
              countermeasures: ie.countermeasures,
              _attributes: {
                exploitId: ie.exploitId,
                exploitTitle: ie.exploitTitle
              }
            };
          })
        };
    }

    private static getExploitsForBackend(exploits: string[]) {
        return { exploit: exploits.map(e => {
            return {_attributes: {exploitId: e}};
          })
        };
    }

    private static getElementsFromComplexProcessForBackend(elements: (Process | ExternalEntity | DataStore)[]) {
        const that = this;
        const elementsObj = {};
        // elements moze biti Process | DataStore | ExternalEntity
        elements.forEach((element: any) => {
            const attributes: any = {
              id: element.id,
              name: element.name,
              outOfScope: element.outOfScope,
              outOfScopeReason: element.outOfScopeReason,
              runLevel: element.runLevel
            };
            const section = element.section.trim();
            if (section !== '') {
              attributes.section = section;
            }

            if (element.sanitizeInput !== undefined) {
                attributes.sanitizeInput = element.sanitizeInput;
            }
            if (element.sanitizeOutput !== undefined) {
                attributes.sanitizeOutput = element.sanitizeOutput;
            }
            if (element.hasForgeryProtection !== undefined) {
                attributes.hasForgeryProtection = element.hasForgeryProtection;
            }
            if (element.sessionHasTimeouts !== undefined) {
                attributes.sessionHasTimeouts = element.sessionHasTimeouts;
            }
            if (element.requiresAuthentication !== undefined) {
                attributes.requiresAuthentication = element.requiresAuthentication;
            }
            if (element.requiresAuthorization !== undefined) {
                attributes.requiresAuthorization = element.requiresAuthorization;
            }
            if (element.isThreadSafe !== undefined) {
              attributes.isThreadSafe = element.isThreadSafe;
            }
            if (element.dataIsEncrypted !== undefined) {
              attributes.dataIsEncrypted = element.dataIsEncrypted;
            }
            if (element.dataIsSigned !== undefined) {
                attributes.dataIsSigned = element.dataIsSigned;
            }
            if (element.storeCredentials !== undefined) {
                attributes.storeCredentials = element.storeCredentials;
            }
            if (element.hasBackup !== undefined) {
              attributes.hasBackup = element.hasBackup;
            }

            const elementForBackend = {
              exploits: that.getExploitsForBackend(element.exploits),
              importExploits: that.getImportExploitsForBackend(element.importExploits),
              assets: BackendDataFormatUtils.getAssetsForBackend(element.assets),
              cpeItems: that.getCpeItemsForBackend(element.cpeItems),
              _attributes: attributes
            };

            if (elementsObj[element.kind] === undefined) {
              elementsObj[element.kind] = [];
            }
            elementsObj[element.kind].push(elementForBackend);
        });

        return elementsObj;
    }

    private static getBoundariesForBackend(boundaries: TrustBoundary[]) {
        const boundariesObj = {};
        boundaries.map(b => {
            const boundaryForBackend = {
                _attributes: {
                  id: b.id,
                  name: b.name
                }
            };

            if (boundariesObj[b.kind] === undefined) {
              boundariesObj[b.kind] = [];
            }
            boundariesObj[b.kind].push(boundaryForBackend);
        });
        return boundariesObj;
    }

}

