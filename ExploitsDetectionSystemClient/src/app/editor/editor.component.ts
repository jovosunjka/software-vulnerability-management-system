import { Component, OnInit, ViewChild } from '@angular/core';
import { View } from '../shared/model/enum/view.enum';
import { ThreatModel } from '../shared/model/threat-model';
import { Guid } from 'guid-typescript';
// import { LoadModelService } from './services/load-model/load-model.service';
import { ToastrService } from 'ngx-toastr';
import { GraphicElement } from '../shared/model/graphic-element';
import { DataFlowDiagramsService } from './data-flow-diagrams-panel/service/data-flow-diagrams.service';
import { CanvasService } from './canvas/service/canvas.service';
import { RunLevel } from '../shared/model/enum/run-level.enum';
// import { FormGroup, Validators, FormBuilder } from '@angular/forms';
import * as xmlJs from 'xml-js';
import { BackendDataFormatUtils } from '../shared/utils/backend-data-format-utils';
import { AnalyzerService } from '../shared/services/analyzer/analyzer.service';
import { ActivatedRoute } from '@angular/router';
import { filter } from 'rxjs/operators';
import { Template } from '../shared/model/template';
import { Threat } from '../shared/model/threat';
import * as FileSaver from 'file-saver';
import { Subscription } from 'rxjs';
import { ThreatsAndVulnerabilities } from '../shared/model/threats-and-vulnerabilities';
import { ThreatsAndVulnerabilitiesPanelComponent } from './threats-and-vulnerabilities-panel/threats-and-vulnerabilities-panel.component';
import { ThreatsAndVulnerabilitiesAndWeaknesses } from '../shared/model/threats-and-vulnerabilities-and-weaknesses';
import { ThreatsAndVulnerabilitiesAndWeaknessesPanelComponent } from './threats-and-vulnerabilities-and-weaknesses-panel/threats-and-vulnerabilities-and-weaknesses-panel.component';

// u fajlu angular.json, u atribut scripts ubaceno je: "node_modules/bootbox/dist/bootbox.min.js"
declare const bootbox: any;


@Component({
  selector: 'app-editor',
  templateUrl: './editor.component.html',
  styleUrls: ['./editor.component.css']
})
export class EditorComponent implements OnInit {

  templateId: string;

  model: ThreatModel;

  buttonText: string;
  private switchToDesignView = 'Switch To Design View';
  private switchToAnalysisView = 'Switch To Analysis View';

  currentDiagram: string;

  view: View;

  selectedItems: boolean;

  diagramsTabMaxLength = 5;

  staticPoints: boolean;

  // threatsAndVulnerabilities: ThreatsAndVulnerabilities;
  threatsAndVulnerabilitiesAndWeaknesses: ThreatsAndVulnerabilitiesAndWeaknesses;

  pleaseWaitDialog: any;

  // @ViewChild(ThreatsAndVulnerabilitiesPanelComponent, {static: false}) tAndVPanelComponent: ThreatsAndVulnerabilitiesPanelComponent;
  @ViewChild(ThreatsAndVulnerabilitiesAndWeaknessesPanelComponent, {static: false})
  tAndVPanelComponent: ThreatsAndVulnerabilitiesAndWeaknessesPanelComponent;

  // form: FormGroup;
  // fileName: string;


  constructor(private dataFlowDiagramsService: DataFlowDiagramsService, private canvasService: CanvasService,
              private analyzerService: AnalyzerService, private route: ActivatedRoute, private toastr: ToastrService) {
    // this.model = this.loadModelService.getThreatModel();
    this.view = View.DESIGN;
    this.buttonText = this.switchToAnalysisView;
    this.selectedItems = false;
    this.staticPoints = false;
    this.threatsAndVulnerabilitiesAndWeaknesses = {
        threats: [],
        vulnerabilities: [],
        weaknesses: []
    };
  }

  ngOnInit() {
    // https://alligator.io/angular/query-parameters/
    this.route.queryParams.pipe(
      filter(params => params.template)
    )
    .subscribe(params => {
        console.log(params);
        this.templateId = params.template;
      }
    );

    this.canvasService.changeSelectedItemsEvent.subscribe(
      (selectedItems: boolean) => this.selectedItems = selectedItems
    );

    this.doDeleteKeyDown();
  }

  /*createForm() {
    this.form = this.fb.group({
      threatModel: [null, Validators.required]
    });
  }*/

  onFileChange(event, that) {
    if (event.target.files.length > 0) {
      const file = event.target.files[0];
      if (file) {
        that.reset();

        const  reader = new FileReader();
        reader.readAsText(file, 'UTF-8');
        reader.onload = function (evt) {
          const target: any = evt.target;
          that.model = JSON.parse(target.result); // postavljamo novi threat moodel ucitan iz json fajla
          that.templateId = that.model.template;
          if (that.model.diagrams.length > 0) {
            that.setCurrentDiagram(that.model.diagrams[0].id);
          } else {
            that.toastr.warning('There are no diagrams in the loaded model!');
          }
        };
        reader.onerror = function (evt) {
            alert('LOAD .json (ERROR)');
        };

        const inputFile: any = document.getElementById('id_path_to_existing_model');
        inputFile.value = ''; // restujemo
      }
      // this.form.get('threatModel').setValue(file);
    }
  }

  createNewModel() {
    const that = this;
    bootbox.prompt({
        title: 'Enter a name for the new model',
        centerVertical: true,
        buttons: {
            confirm: {
                label: 'CREATE',
                className: 'btn-success'
            },
            cancel: {
                label: 'CANCEL',
                className: 'btn-danger'
            }
        },
        callback: function (name) {
            if (name) {
              name = name.trim();
            }
            console.log('This was logged in the callback: ' + name);

            if (name === '') {
              that.toastr.error('You did not enter the name of the new model!');
              return false;
              // that.createNewModel();
            } else if (name && name !== '') {
              that.reset();
              that.continueCreateNewModel(name);
            }
        }
    });
  }

  /*
  createNewDiagram() {
    const that = this;
    bootbox.prompt({
        title: 'Enter a name for the new diagram',
        centerVertical: true,
        buttons: {
            confirm: {
                label: 'CREATE',
                className: 'btn-success'
            },
            cancel: {
                label: 'CANCEL',
                className: 'btn-danger'
            }
        },
        callback: function (name) {
            if (name) {
              name = name.trim();
            }
            console.log('This was logged in the callback: ' + name);

            if (name === '') {
              that.toastr.error('You did not enter the name of the new diagram!');
              return false;
            } else if (that.model.diagrams.map(d => d.name).includes(name)) {
              that.toastr.error('A diagram named ' + name + ' already exists in this model!');
              return false;
            } else if (name && name !== '') {
              that.continueCreateNewDiagram(name);
            }
        }
    });
  }
  */

  continueCreateNewModel(nameOfNewModel: string) {
    const newModelId = 'id-' + Guid.create().toString();
    const firstDiagramId = newModelId + '_id-diagram-0';
    this.model = {
      id: newModelId,
      name: nameOfNewModel,
      template: this.templateId,
      diagrams: [
        {
          id: firstDiagramId,
          name: 'Context',
          graph: {
              nodes: [],
              links: [],
              boundaries: [],
              sections: [],
              translateX: 0,
              translateY: 0,
              scale: 1
          },
          elements: [],
          flows: [],
          boundaries: [],
          sections: [],
          complexProcess: false
        }
      ]
    };

    this.toastr.success('You have successfully created a new model!');
  }

  /*
  continueCreateNewDiagram(nameOfNewDiagram: string) {
      this.dataFlowDiagramsService.addNew(nameOfNewDiagram);
  }
  */

  switchView() {
    if (this.view === View.DESIGN) {
      this.view = View.ANALYSIS;
      this.buttonText = this.switchToDesignView;
      this.diagramsTabMaxLength = 2;
    } else {  // Analysis view
      this.view = View.DESIGN;
      this.buttonText = this.switchToAnalysisView;
      this.diagramsTabMaxLength = 5;
    }
  }

  analysisView() {
    if (this.view !== View.ANALYSIS) {
      this.view = View.ANALYSIS;
      this.buttonText = this.switchToDesignView;
      this.diagramsTabMaxLength = 2;
    }
  }

  isDesignView() {
    return this.view === View.DESIGN;
  }

  isAnalysisView() {
    return this.view === View.ANALYSIS;
  }

  dataFlowDaigrmasPanelColSize() {
    if (this.view === View.DESIGN) {
      return 8;
    } else {  // Analysis view
      return 4;
    }
  }

  setCurrentDiagram(currentDiagram: string) {
    this.currentDiagram = currentDiagram;
  }

  getDateTimeStr() {
    const today = new Date();
    const date = today.getDate() + '.' + (today.getMonth() + 1 ) + '.' + today.getFullYear();
    const time = today.getHours() + ';' + today.getMinutes() + ';' + today.getSeconds();
    const dateTime = date + '-' + time;
    return dateTime;
  }

  export() {
      const that = this;

      bootbox.prompt({
        title: '* Be sure to check at least one format in which you want to export the model!',
        centerVertical: true,
        buttons: {
          confirm: {
              label: 'EXPORT',
              className: 'btn-success'
          },
          cancel: {
              label: 'CANCEL',
              className: 'btn-danger'
          }
        },
        value: ['1', '2'],
        inputType: 'checkbox',
        inputOptions: [
          {
              text: 'Export graphical data',
              value: '1'
          },
          {
            text: 'JSON format',
            value: '2'
          },
          {
            text: 'XML format',
            value: '3',
          }
        ],
        callback: function (result: string[]) {
            console.log(result);
            if (result !== null) {
              let model;
              if (result.includes('1')) {
               model = that.model;
              } else {
                model = that.getModelWithoutGraph();
              }

              let selectedFormat = false;
              if (result.includes('2')) {
                selectedFormat = true;
                const jsonText = JSON.stringify(model, null, 2); // spacing level = 2
                that.download(jsonText, 'json');
              }

              if (result.includes('3')) {
                selectedFormat = true;
                const contextDiagramForBackend = BackendDataFormatUtils.preparContextDiagramForBackendForConvertingInXml(model);
                const contextDiagramForBackendXml = xmlJs.js2xml(
                      {
                        _declaration: {
                          _attributes: {
                            version: '1.0',
                            encoding: 'UTF-8'
                          }
                        },
                        diagram: contextDiagramForBackend
                      },
                      {compact: true, spaces: 4}
                );
                that.download(contextDiagramForBackendXml, 'xml');
              }

              if (!selectedFormat) {
                that.toastr.error('You did not select format!');
                return false;
              }

            }
        }
    });
  }
  getModelWithoutGraph(): ThreatModel {
    if (!this.model) {
      return null;
    }

    const modelWithoutGraph = {
      id: this.model.id,
      name: this.model.name,
      diagrams: []
    };
    this.model.diagrams.forEach( diagram => {
      const copyDiagram =  Object.assign({}, diagram);
      delete copyDiagram.graph;
      modelWithoutGraph.diagrams.push(copyDiagram);
    });

    return modelWithoutGraph;
  }

  download(content, documentFormat) {
    const element = document.createElement('a');
    element.setAttribute('href', 'data:application/' + documentFormat + ';charset=utf-8,' + encodeURIComponent(content));
    const dateTimeStr = this.getDateTimeStr();
    element.setAttribute('download', this.model.name + '_' + dateTimeStr + '.' + documentFormat);

    element.style.display = 'none';
    document.body.appendChild(element);

    element.click();

    document.body.removeChild(element);
  }

  doDeleteKeyDown() {
    const that = this;
    document.addEventListener('keydown', function(event) {
      if (event.key === 'Delete' && that.selectedItems) {
        that.deleteSelectedItems();

        // Prevent the browser from going back in the URL history
        event.preventDefault();
        event.stopPropagation();
      }
  });
  }

  deleteSelectedItems()  {
    this.canvasService.doAction(this.currentDiagram, 'remove-selected-graphic-elements', null);
    this.toastr.info('Delete selected items');
  }

  analyze() {
    let uploadDiagramSubscription: Subscription;
    const onCloseCallback = () => {
      if (uploadDiagramSubscription) {
        uploadDiagramSubscription.unsubscribe();
      }
      this.closePleaseWaitDialog();
    };
    this.showPleaseWaitDialog(onCloseCallback);

    const modelWithoutGraph = this.getModelWithoutGraph();
    const contextDiagramForBackend = BackendDataFormatUtils.preparContextDiagramForBackendForConvertingInXml(modelWithoutGraph);
    const contextDiagramForBackendXml = xmlJs.js2xml(
            {
              _declaration: {
                _attributes: {
                  version: '1.0',
                  encoding: 'UTF-8'
                }
              },
              diagram: contextDiagramForBackend
            },
            {compact: true, spaces: 4}
      );

    console.log('JSON:');
    console.log(JSON.stringify(contextDiagramForBackend));
    console.log('XML:');
    console.log(contextDiagramForBackendXml);
    this.analysisView();

    uploadDiagramSubscription = this.analyzerService.uploadDiagramXml(contextDiagramForBackendXml)
                                    .subscribe((threatsAndVulnerabilitiesAndWeaknesses: ThreatsAndVulnerabilitiesAndWeaknesses) => {
        // alert(JSON.stringify(threats));
        this.closePleaseWaitDialog();
        this.toastr.success('Successfully analyzed diagram');
        this.threatsAndVulnerabilitiesAndWeaknesses = threatsAndVulnerabilitiesAndWeaknesses;
      }, (error) => {
        this.closePleaseWaitDialog();
        console.log(error);
        this.toastr.error(error.error);
      }
    );
  }

  showPleaseWaitDialog(onCloseCallback) {
    this.pleaseWaitDialog = bootbox.dialog({
      message: '<p class="text-center mb-0"><i class="fa fa-spin fa-spinner"></i> Please wait...</p>',
      centerVertical: true,
      closeButton: false,
      buttons: {
        close: {
          label: 'CLOSE',
          className: 'btn-primary',
          callback: onCloseCallback
        }
      }
    });
  }

  closePleaseWaitDialog() {
    if (this.pleaseWaitDialog) {
      this.pleaseWaitDialog.modal('hide');
      this.pleaseWaitDialog = null;
    }
  }

  createReport() {
    const modelWithoutGraph = this.getModelWithoutGraph();
    const contextDiagramForBackend = BackendDataFormatUtils.preparContextDiagramForBackendForConvertingInXml(modelWithoutGraph);
    const contextDiagramForBackendXml = xmlJs.js2xml(
            {
              _declaration: {
                _attributes: {
                  version: '1.0',
                  encoding: 'UTF-8'
                }
              },
              diagram: contextDiagramForBackend
            },
            {compact: true, spaces: 4}
    );

    this.getReport(contextDiagramForBackendXml, modelWithoutGraph.name);
  }

  getReport(contextDiagramForBackendXml, modelName) {
    // report's filename
    const fileName = 'Report' + '-' + modelName + '.pdf';

    const onCloseCallback = () => {
      if (reportSubscription) {
        reportSubscription.unsubscribe();
      }
      this.closePleaseWaitDialog();
    };

    this.showPleaseWaitDialog(onCloseCallback);

    const reportSubscription: Subscription = this.analyzerService.createReportWithFileName(contextDiagramForBackendXml,
                                                                                               modelName)
        .subscribe(report => {
          // this.loading = false;
          this.closePleaseWaitDialog();


          this.toastr.success('Successfully analyzed diagram');
          const blob = new Blob([report], {type: 'application/pdf;charset=utf-8'});
          FileSaver.saveAs(blob, fileName);

      }, (error) => {
        console.log(error);
        // this.loading = false;
        this.closePleaseWaitDialog();
        this.toastr.error(error.error);
      }
    );
  }

  resetThreatListPanel() {
    this.threatsAndVulnerabilitiesAndWeaknesses.threats = [];
  }

  resetVulnerabilityListPanel() {
    this.threatsAndVulnerabilitiesAndWeaknesses.vulnerabilities = [];
  }

  resetWeaknessListPanel() {
    this.threatsAndVulnerabilitiesAndWeaknesses.weaknesses = [];
  }

  reset() {
    this.resetThreatListPanel();
    this.resetVulnerabilityListPanel();
    this.resetWeaknessListPanel();

    if (this.tAndVPanelComponent) {
      this.tAndVPanelComponent.resetThreatAnalysisPanel();
    }

    if (this.tAndVPanelComponent) {
      this.tAndVPanelComponent.resetVulnerabilityAnalysisPanel();
    }

    if (this.tAndVPanelComponent) {
      this.tAndVPanelComponent.resetWeaknessAnalysisPanel();
    }
  }

}
