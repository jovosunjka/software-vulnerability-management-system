import {Component, OnInit} from '@angular/core';
import {ToastrService} from 'ngx-toastr';
import * as FileSaver from 'file-saver';
import { AnalyzerService } from 'src/app/shared/services/analyzer/analyzer.service';
import { StencilsConfigService } from 'src/app/shared/services/stencils-config/stencils-config.service';
import { Template } from 'src/app/shared/model/template';

@Component({
  selector: 'app-analyze-diagram',
  templateUrl: './analyzer.component.html',
  styleUrls: ['./analyzer.component.css']
})
export class AnalyzerComponent implements OnInit {
  sourceDiagram: File;
  xmlSchema: File;
  exploits: File;

  loading: boolean;

  templates: Template[];

  queryParamsForEditor: any;


  constructor(private analyzerService: AnalyzerService, private stencilsConfigService: StencilsConfigService,
              private toastr: ToastrService) {
      this.templates = [];
      this.queryParamsForEditor = {
        template: ''
      };
  }

  ngOnInit() {
    window.scrollTo(0, 0);   // keep scroll position at the top of the page

    this.getTemplates();
  }

  // handleFileInput(files: FileList, key: string) {
  //   this.filesToUpload[key] = files.item(0);
  // }

  private getTemplates() {
    this.stencilsConfigService.getTemplates().then((templates: Template[]) => {
      this.templates = templates;
      if (this.templates.length > 0) {
        this.queryParamsForEditor.template = this.templates[0].id;
      }
    });
  }

  analyzeDiagram() {
    if (this.sourceDiagram === undefined || this.xmlSchema === undefined || this.exploits === undefined) {
      this.toastr.warning('Upload all files');
      return;
    }

    this.loading = true;

    this.analyzerService.uploadFiles(this.sourceDiagram, this.xmlSchema, this.exploits).subscribe(data => {
        for (let i = 0; i < data['length']; i++) {
          this.loading = false;
          const exploitsList = data[i].exploits;
          const exploitsToStay = [];
          // tslint:disable-next-line:prefer-for-of
          for (let j = 0; j < exploitsList.length; j++) {
            if (confirm('Do you want to keep this exploit?\nDestination element: ' + data[i].element +
              '\nExploit: ' + exploitsList[j])) {
              exploitsToStay.push(exploitsList[j]);
            }
          }
          data[i].exploits = exploitsToStay;
        }
        this.loading = true;
        this.getReport(data);

      }, (error) => {
        console.log(error);
        this.loading = false;
        this.toastr.error(error.error);
      }
    );
  }

  getReport(data) {
    // report's filename
    const fileName = 'Report' + '-' + this.sourceDiagram.name + '.pdf';

    this.analyzerService.getReport(data).subscribe(report => {
        this.loading = false;

        this.toastr.success('Successfully analyzed diagram');
        const blob = new Blob([report], {type: 'application/pdf;charset=utf-8'});
        FileSaver.saveAs(blob, fileName);

      }, (error) => {
        console.log(error);
        this.loading = false;
        this.toastr.error(error.error);
      }
    );
  }
}
