package com.eds.EDSSolution.service.impl;

import com.eds.EDSSolution.EDS_Library.diagram.*;
import com.eds.EDSSolution.exceptions.*;
import com.eds.EDSSolution.model.dto.ElementExploitDTO;
import com.eds.EDSSolution.model.report.*;
import com.eds.EDSSolution.model.risk_pattern.CVEitem;
import com.eds.EDSSolution.model.risk_pattern.DiagramPattern;
import com.eds.EDSSolution.service.DiagramAnalyzerService;
import com.eds.EDSSolution.service.NVDvulnerabilitiesService;
import com.eds.EDSSolution.service.ReportService;
import com.eds.EDSSolution.utils.*;
import org.apache.fop.apps.FOPException;
import org.json.simple.parser.ParseException;
import org.kie.api.runtime.StatelessKieSession;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.InputStreamResource;
import org.springframework.stereotype.Service;
import org.xml.sax.SAXException;

import javax.xml.bind.JAXBElement;
import javax.xml.bind.JAXBException;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.TransformerException;
import java.io.*;
import java.util.*;

@Service
public class DiagramAnalyzerServiceImpl implements DiagramAnalyzerService {

    @Autowired
    private NVDvulnerabilitiesService nvdVulnerabilitiesService;

    @Autowired
    private ReportService reportService;

    /**
     * This method starts the analyzing process. There are several steps:
     * 1. Validate diagrams
     * 2. Decompose xml diagram into elements and flows
     * 3. Search for the complex processes
     * 4. If complex process exists:
     *      a) Decompose complex process into elements and flows
     *      b) Find patterns
     *      c) Fire rules
     *      d) Read exploits found on the complex process
     *      e) Merge exploits with definitions
     *
     * Two xml files are specified by the user of the system (diagramFile and exploits)
     *
     * @param diagramFile       xml diagram that should be analyzed
     * @param exploits          exploits definitions
     * @return list of all exploits found on the complex processes
     */
    @Override
    public List<ElementExploitDTO> startAnalyzer(File diagramFile, File exploits) {

        if (!validateDiagrams(diagramFile, exploits)) {
            return null;
        }

        List<ElementExploitDTO> elementExploits = new ArrayList<>();

        Decomposer decomposer = decomposeDiagram(diagramFile);
        decomposer.setComplexProcess();   // if there are any complex processes on the diagram set them

        if (decomposer.getComplexProcesses().size() != 0) {
            for (Diagram.Elements.ComplexProcess complexProcess : decomposer.getComplexProcesses()) {
                Decomposer cpDecomposer = new Decomposer(complexProcess);

                /* ********	        DECOMPOSE COMPLEX PROCESS 		***********/
                List<DiagramPattern> complexProcessPatterns = cpDecomposer.decomposeAllPatterns();

                /* ********	        FIRE RULES      		 		***********/
                if (createAndFireRules(complexProcessPatterns)) {
                    return null;
                }
                /* ********	        READ EXPLOITS	   	 		   ***********/
                ExploitDefinitions exploitDefinitions = readExploitDefinitions(exploits);

                /* ********	        MERGE EXPLOITS AND DIAGRAMS	  ***********/
                DiagramMerge mergeExploits = new DiagramMerge(complexProcessPatterns, exploitDefinitions);
                complexProcessPatterns = mergeExploits.mergeExploitsToDiagramPieces();

                elementExploits.addAll(getElementExploitsList(complexProcessPatterns));
            }
        }
        return elementExploits;
    }


    /**
     * This method ends the analyzing process and creates final report. Steps:
     * 1. Decompose xml diagram into elements and flows
     * 2. Find patterns
     * 3. Fire rules
     * 4. Get all publicly knows vulnerabilities
     * 5. Read exploits
     * 6. Merge exploits with definitions
     * 7. Create ReportClass
     * 8. Create report - xml format
     * 9. Transform report to PDF format
     *
     * @param complexProcessElementExploits list of all exploits that should be added into final report
     * @param diagramFile                   xml diagram that is analyzed
     * @param exploits                      exploits definitions
     * @return final report
     * @throws TransformerException when transforming report into PDF
     * @throws IOException          when parsing NVD file
     * @throws FOPException         when transforming report into PDF
     * @throws ParseException       when parsing NVD file
     */
    @Override
    public InputStreamResource endAnalyzer(List<ElementExploitDTO> complexProcessElementExploits, File diagramFile,
                                           File exploits) throws TransformerException,
            IOException, FOPException, ParseException {

        Decomposer decomposer = decomposeDiagram(diagramFile);
        List<DiagramPattern> patterns = decomposer.decomposeAllPatterns();

        if (patterns.size() == 0) {
            return null;
        }

        /* ********	        ANALYZING DIAGRAM COMPONENTS	***********/
        if (createAndFireRules(patterns)) {
            return null;
        }

        /* ********	        REQUEST TO NVD FOR VULNERABILITIES  **********/
        ReportVulnerabilities vulnerabilities = analyzeVulnerabilitiesForComponentTechnologies(decomposer);

        /* ********	        READING EXPLOITS		 		***********/
        ExploitDefinitions exploitDefinitions = readExploitDefinitions(exploits);

        /* ********	        MERGING EXPLOITS AND DIAGRAMS	***********/
        DiagramMerge mergeExploits = new DiagramMerge(patterns, exploitDefinitions);
        patterns = mergeExploits.mergeExploitsToDiagramPieces();

        /* ********	        CREATING REPORT	PATTERN			**********/
        ReportClass report = createReportPatternsFromDiagramPatterns(diagramFile, patterns, complexProcessElementExploits, exploitDefinitions);

        /* ********	        CREATING XML REPORT				***********/
        String reportXml = createXMLReport(report, vulnerabilities);

        return reportService.generatePDF(reportXml);
    }


    /**
     * Helper method that calls two other methods, that check if diagrams are valid.
     * If both diagrams, given by user, are valid method will return true.
     *
     * @param diagramFile xml diagram that should be analyzed
     * @param exploits    xml file that contains exploits definitions
     * @return true if validation was successful
     */
    private boolean validateDiagrams(File diagramFile, File exploits) {
        ResourcesLocation resourcesLocation = new ResourcesLocation();
        String schemaPath = resourcesLocation.getSchemaLocation();

        /* ********	        VALIDATING XML DIAGRAM			**********/
        if (!validateDiagram(diagramFile, schemaPath)) {
            return false;
        }

        /* ********	        VALIDATING XML EXPLOITS			***********/
        return validateExploitDefinitions(exploits, resourcesLocation.getExploitSchema());
    }


    /**
     * Method returns true if the xml diagram is valid.
     * Syntax and semantic check.
     *
     * @param diagramFile xml diagram that should be analyzed
     * @param schemaPath  path to the schema of the diagramFile
     * @return true if the diagram is valid
     */
    private boolean validateDiagram(File diagramFile, String schemaPath) {
        try {
            Validator.checkWellFormness(diagramFile);
        } catch (ParserConfigurationException e) {
            throw new ParserCouldNotBeInitializedException("Parser could not be initialized!\nPlease try again.");
        } catch (SAXException e) {
            throw new XMLFileNotWellFormedException("XML Diagram is not well formed!\nXML Diagram contains syntax errors." +
                    " Please choose another diagram or fix current.");
        } catch (IOException e) {
            throw new FileNotReadableException("File could not be read!\nPlease load file again and try again.");
        }

        try {
            Validator.checkDiagramValidity(diagramFile, schemaPath);
        } catch (SAXException e) {
            throw new XMLFileNotValidException("XML Diagram is not valid!\nXML Diagram contains semantic errors. " +
                    "Please choose another diagram or fix current.");
        } catch (IOException e) {
            throw new FileNotReadableException("File could not be read!\nPlease load file again and try again.");
        }
        return true;
    }


    /**
     * Method returns true if the xml with exploits is valid.
     * Syntax and semantic check.
     *
     * @param exploitsFile xml file that contains exploits definitions
     * @param schemaPath   path to the schema of the exploitsFile
     * @return true if the diagram is valid
     */
    private boolean validateExploitDefinitions(File exploitsFile, String schemaPath) {
        try {
            Validator.checkWellFormness(exploitsFile);
        } catch (ParserConfigurationException e) {
            throw new ParserCouldNotBeInitializedException("Parser could not be initialized!\nPlease try again.");
        } catch (SAXException e) {
            throw new XMLFileNotWellFormedException("Exploit Definitions XML file is not well formed!\nXML File has " +
                    "been unauthorizedly modified and contains syntax errors. Please contact the support.");
        } catch (IOException e) {
            throw new FileNotReadableException("File could not be read!\nPlease load file again and try again.");
        }

        try {
            Validator.checkExploitDefinitionsValidity(exploitsFile, schemaPath);
        } catch (SAXException e) {
            throw new XMLFileNotValidException("Exploit Definitions XML file is not valid!\nXML File has been" +
                    "unauthorizedly modified and contains semantic errors. Please contact the support.");
        } catch (IOException e) {
            throw new FileNotReadableException("File could not be read!\nPlease load file again and try again.");
        }
        return true;
    }

    /**
     * This method decomposes diagram into elements and flows.
     *
     * @param diagramFile diagram that is analyzed
     * @return Decomposer
     */
    private Decomposer decomposeDiagram(File diagramFile) {
        /* ********	        READING XML DIAGRAM TO MEMORY	***********/
        Diagram diagram = readDiagram(diagramFile);

        /* ********	        DECOMPOSING XML DIAGRAM			**********/
        return new Decomposer(diagram);
    }

    /**
     * Method returns Diagram that is read to the memory.
     *
     * @param diagramFile xml diagram that should be analyzed
     * @return Diagram
     */
    private Diagram readDiagram(File diagramFile) {
        try {
            return XMLLinker.readXMLDiagram(diagramFile);
        } catch (JAXBException e) {
            throw new ParserCouldNotBeInitializedException("Parser could not be initialized!\nPlease try again.");
        }
    }

    /**
     * Method returns ExploitDefinitions that is read to the memory.
     *
     * @param exploitsFile xml file that contains exploits definitions
     * @return ExploitDefinitions
     */
    private ExploitDefinitions readExploitDefinitions(File exploitsFile) {
        try {
            return XMLLinker.readXMLExploits(exploitsFile);
        } catch (JAXBException e) {
            throw new ParserCouldNotBeInitializedException("Parser could not be initialized!\nPlease try again.");
        }
    }

    /**
     * Method creates StatelessKieSession and examines each pattern
     *
     * @param patterns list with found patterns
     * @return false if there were no Exceptions
     */
    private boolean createAndFireRules(List<DiagramPattern> patterns) {

        StatelessKieSession session;
        try {
            session = KieRulesBase.createStatelessSession();
        } catch (RuntimeException e) {
            throw new RuleFilesException("Rule base could not be built!\nThere is an error in rule definition files.");
        }
        if (session == null) {
            throw new NoRulesFilesLocationException("There are no rules files locations defined!\nPlease check the" +
                    "'resources/locations.txt' file.");
        }

        for (DiagramPattern diagramPattern : patterns) {
            session.execute(diagramPattern);
        }
        return false;
    }

    /**
     * This method analyzes all elements and checks if there are any publicly knows vulnerabilities for the
     * CPEs that are specified on the diagram elements.
     *
     * @param diagramElements Decomposer with elements and flows
     * @return ReportVulnerabilities
     * @throws IOException    when parsing file
     * @throws ParseException when parsing file
     */
    private ReportVulnerabilities analyzeVulnerabilitiesForComponentTechnologies(Decomposer diagramElements) throws IOException, ParseException {
        ReportVulnerabilities reportVulnerabilities = new ReportVulnerabilities();
        List<ReportElementVulnerabilities> elementVulnerabilities = new ArrayList<>();

        for (JAXBElement diagramElement : diagramElements.getDiagramElements()) {
            // skip complex process for now
            if (diagramElement.getDeclaredType() == Diagram.Elements.ComplexProcess.class) {
                continue;
            }
            BlockElement blockElement = (BlockElement) diagramElement.getValue();
            CpeItems cpeItems = blockElement.getCpeItems();

            // check all CPEs that are defined for one element
            for (CpeItems.CpeItem cpItem : cpeItems.getCpeItems()) {
                List<CVEitem> cveList = nvdVulnerabilitiesService.findCVEforCPE(cpItem.getCpeUrl(), 0);

                // if there is at least one CVE add it to report
                if (cveList.size() != 0) {
                    ReportElementVulnerabilities reportVulnerability = new ReportElementVulnerabilities(blockElement, cveList);
                    elementVulnerabilities.add(reportVulnerability);
                }
            }
        }

        reportVulnerabilities.setElementVulnerabilities(elementVulnerabilities);
        return reportVulnerabilities;
    }

    /**
     * This method creates report patterns (ReportClass).
     *
     * @param diagramFile            xml diagram that should be analyzed
     * @param patterns               all found patterns
     * @param complexProcessExploits all found exploits on the complex processes
     * @param exploitDefinitions     exploit definitions
     * @return ReportClass
     */
    private ReportClass createReportPatternsFromDiagramPatterns(File diagramFile, List<DiagramPattern> patterns,
                                                                List<ElementExploitDTO> complexProcessExploits,
                                                                ExploitDefinitions exploitDefinitions) {
        List<ReportPattern> reports = new ArrayList<>();

        for (DiagramPattern diagramPattern : patterns) {
            if (diagramPattern.getExploitValues().size() > 0) {
                reports.add(new ReportPattern(diagramPattern));
            }
        }

        return new ReportClass(reports, diagramFile.getName(), complexProcessExploits, exploitDefinitions);
    }

    /**
     * This method writes the xml report file.
     *
     * @param report          ReportClass
     * @param vulnerabilities all found publicly know vulnerabilities
     * @return report in xml format
     */
    private String createXMLReport(ReportClass report, ReportVulnerabilities vulnerabilities) {
        // set found vulnerabilities
        report.setVulnerabilities(vulnerabilities);

        try {
            return XMLLinker.writeXMLReportFile(report);
        } catch (JAXBException e) {
            throw new ReportFileNotWrittenException("Report File could not be written!\nPlease try again.");
        }
    }

    /**
     * Helper method that iterates through all patterns, found on the complex process, and
     * creates list of ElementExploitDTOs that is going to be returned to the user.
     *
     * @param complexProcessPatterns all patterns found on complex process
     * @return List<ElementExploitDTO>
     */
    private List<ElementExploitDTO> getElementExploitsList(List<DiagramPattern> complexProcessPatterns) {
        List<ElementExploitDTO> elementExploits = new ArrayList<>();

        for (DiagramPattern dp : complexProcessPatterns) {
            ElementExploitDTO elementExploitDTO = new ElementExploitDTO(dp.getElement().getName(),
                    "", dp.getFoundExploits());
            elementExploits.add(elementExploitDTO);
        }
        return elementExploits;
    }


    @SuppressWarnings("unused")
    private void printDiagramPatterns(List<DiagramPattern> diagramPatterns) {
        for (DiagramPattern pattern : diagramPatterns) {
            if (pattern.getTraceStart() != null) {
                System.out.println("\n********* Pattern for " + pattern.getElement().getName() + "\n- Trace for " + pattern.getTraceStart().getName() + ":");
                for (Element element : pattern.getTrace()) {
                    System.out.println("\t " + element.getName());
                }
            } else {
                System.out.println("\n********* Pattern " + pattern.getElement().getName() + " with no trace");
            }
        }
    }

    @SuppressWarnings("unused")
    private void printRawExploitsForDiagramPatterns(List<DiagramPattern> diagramPatterns) {
        for (DiagramPattern pattern : diagramPatterns) {
            if (pattern.getTraceStart() != null) {
                System.out.println("*******************\nExploits on element " + pattern.getElement().getName() + "\n- Trace for " + pattern.getTraceStart().getName() + ":");
                for (String exploit : pattern.getFoundExploits()) {
                    if (exploit != null) {
                        System.out.println("\t\t- " + exploit); //+ " \t asset: " + exploit.getAsset());
                    }
                }
            } else {
                System.out.println("*******************\nExploits on element " + pattern.getElement().getName() + " with no trace:");
                for (String exploit : pattern.getFoundExploits()) {
                    if (exploit != null) {
                        System.out.println("\t\t- " + exploit); // + " \t asset: " + exploit.getAsset());
                    }
                }
            }
        }
    }

    @SuppressWarnings("unused")
    private void printExploitsForDiagramPatterns(List<DiagramPattern> diagramPatterns) {
        System.out.println("\n*************************************************************************");
        System.out.println("*************************************************************************\n");
        for (DiagramPattern pattern : diagramPatterns) {
            if (pattern.getTraceStart() != null) {
                System.out.println("*******************\n" + pattern.getElement().getName() + " from " + pattern.getTraceStart().getName() + ":");
                for (ExploitDefinition exploit : pattern.getExploitValues()) {
                    if (exploit != null) {
                        System.out.println("\t\t- " + exploit.getExploitTitle());
                    }
                }
            } else {
                System.out.println("*******************\n" + pattern.getElement().getName() + " with no trace:");
                for (ExploitDefinition exploit : pattern.getExploitValues()) {
                    if (exploit != null) {
                        System.out.println("\t\t- " + exploit.getExploitTitle());
                    }
                }
            }
        }
    }
}
